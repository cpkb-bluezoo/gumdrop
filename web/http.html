<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "xhtml11.dtd">
<!--
  This file is part of gumdrop.

  gumdrop is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  gumdrop is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with gumdrop; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico"/>
<link rel="SHORTCUT ICON" href="favicon.ico"/>
<title>HTTP Server &amp; Client - Gumdrop</title>
</head>
<body>

<table summary='(layout)'>
<tr>
<td>
<img align="left" border="0" src="gumdrop.png" alt="(gumdrop)" />
</td>
<td valign='bottom'>
<h1 class='offset'>Gumdrop HTTP Server &amp; Client</h1>
</td>
</table>

<p><a href="index.html">&larr; Back to Main Page</a></p>

<p>
Gumdrop provides a comprehensive HTTP implementation supporting HTTP/3,
HTTP/2, and HTTP/1.x. The HTTP layer serves as the foundation for
higher-level services including the <a href="servlet.html">servlet
container</a> and <a href="webdav.html">file server</a>.
</p>

<h3>Contents</h3>
<ul>
<li><a href="#versions">HTTP Versions</a></li>
<li><a href="#http3">HTTP/3 and QUIC</a></li>
<li><a href="#http2">HTTP/2 Support</a></li>
<li><a href="#server-handler">Server Handler API</a></li>
<li><a href="websocket.html">WebSocket Service &amp; Client</a> (separate page)</li>
<li><a href="#upgrades">Protocol Upgrades</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#client">HTTP Client</a></li>
<li><a href="webdav.html">File Server &amp; WebDAV</a> (separate page)</li>
</ul>

<h3 id="versions">HTTP Versions</h3>

<p>
Gumdrop supports HTTP/3, HTTP/2, HTTP/1.1, and HTTP/1.0, with automatic
version detection and negotiation. Originally built to support HTTP/1.1
as a native protocol, Gumdrop was first adapted to use the SPDY protocol
developed by Google, and then, as that was deprecated and consensus
established on the newer HTTP/2 protocol, Gumdrop embraced the efficiency
and extensibility of the latter. With the standardisation of HTTP/3 over
QUIC, Gumdrop now supports the full spectrum of modern HTTP.
</p>

<h4>HTTP/3</h4>

<p>
HTTP/3 (RFC 9114) runs over QUIC instead of TCP. QUIC provides built-in
TLS 1.3 encryption, multiplexed streams without head-of-line blocking,
and faster connection establishment (often 0-RTT). HTTP/3 is configured
via a separate <code>HTTP3Listener</code> that listens on a UDP port.
See <a href="#http3">HTTP/3 and QUIC</a> below for details.
</p>

<h4>HTTP/2</h4>

<p>
Complete HTTP/2 implementation (RFC 7540) with multiplexing and header
compression. HTTP/2 can be negotiated via ALPN during TLS handshake or
via cleartext upgrade (h2c). See <a href="#http2">HTTP/2 Support</a>
below for details.
</p>

<h4>HTTP/1.1</h4>

<p>
Full HTTP/1.1 support including:
</p>
<ul>
<li><b>Persistent connections</b> - connections remain open for multiple
request/response cycles by default</li>
<li><b>Chunked transfer encoding</b> - streaming of request and response
bodies without a priori content length</li>
<li><b>Host header requirement</b> - virtual hosting support</li>
<li><b>Pipelining</b> - multiple requests can be sent without waiting for
responses (though this is rarely used in practice)</li>
</ul>

<h4>HTTP/1.0</h4>

<p>
Basic HTTP support for legacy clients. Connections are closed after each
request/response unless explicitly kept alive.
</p>

<h3 id="http3">HTTP/3 and QUIC</h3>

<p>
HTTP/3 is the latest major version of the Hypertext Transfer Protocol. Unlike
HTTP/1.1 and HTTP/2, which run over TCP, HTTP/3 uses QUIC (RFC 9000) as its
transport layer. QUIC provides:
</p>

<ul>
<li><b>Built-in encryption</b> &ndash; TLS 1.3 is mandatory and integral to the
protocol, with no cleartext mode</li>
<li><b>Multiplexed streams</b> &ndash; like HTTP/2, but without TCP head-of-line
blocking; a lost packet on one stream does not stall others</li>
<li><b>Faster connection establishment</b> &ndash; the TLS handshake is combined
with the transport handshake, often completing in a single round trip
(1-RTT) or zero round trips (0-RTT) for resumed connections</li>
<li><b>Connection migration</b> &ndash; connections survive changes in the
client&rsquo;s IP address (e.g. switching from Wi-Fi to cellular)</li>
</ul>

<h4>Architecture</h4>

<p>
Gumdrop&rsquo;s HTTP/3 support is built on the
<a href="https://github.com/cloudflare/quiche">quiche</a> library via JNI.
The QUIC layer handles connection management, stream multiplexing, and
congestion control natively, while the HTTP/3 framing (HEADERS, DATA,
QPACK) is processed by Gumdrop&rsquo;s <code>HTTP3ServerHandler</code>
and <code>H3Stream</code> classes.
</p>

<p>
From the application&rsquo;s perspective, HTTP/3 is transparent. The same
<code>HTTPRequestHandlerFactory</code> and <code>HTTPRequestHandler</code>
interfaces are used regardless of whether the request arrived over HTTP/3,
HTTP/2, or HTTP/1.1. The only visible difference is the HTTP version
reported by <code>HTTPResponseState.getVersion()</code>.
</p>

<h4>Configuration</h4>

<p>
HTTP/3 is configured by adding an <code>HTTP3Listener</code> to an
HTTP service. Because QUIC uses UDP, the HTTP/3 listener is independent
of the TCP-based <code>HTTPListener</code> and can coexist with it:
</p>

<pre>
&lt;service id="web" class="org.bluezoo.gumdrop.servlet.ServletService"&gt;
  &lt;!-- HTTP/1.1 and HTTP/2 over TCP --&gt;
  &lt;listener class="org.bluezoo.gumdrop.http.HTTPListener"&gt;
    &lt;property name="port"&gt;443&lt;/property&gt;
    &lt;property name="secure"&gt;true&lt;/property&gt;
    &lt;property name="keystore-file"&gt;keystore.p12&lt;/property&gt;
    &lt;property name="keystore-pass"&gt;changeit&lt;/property&gt;
  &lt;/listener&gt;
  &lt;!-- HTTP/3 over QUIC --&gt;
  &lt;listener class="org.bluezoo.gumdrop.http.h3.HTTP3Listener"&gt;
    &lt;property name="port"&gt;443&lt;/property&gt;
    &lt;property name="cert-file"&gt;/etc/gumdrop/cert.pem&lt;/property&gt;
    &lt;property name="key-file"&gt;/etc/gumdrop/key.pem&lt;/property&gt;
  &lt;/listener&gt;
&lt;/service&gt;
</pre>

<p>
Note that the TCP and QUIC listeners can share the same port number (443 is
conventional) because they use different transport protocols (TCP vs UDP).
</p>

<h4>PEM vs Keystore</h4>

<p>
QUIC uses BoringSSL (via the quiche native library) rather than the JDK&rsquo;s
JSSE, so HTTP/3 listeners require PEM-encoded certificates and keys rather
than a Java keystore:
</p>

<ul>
<li><code>cert-file</code> &ndash; path to the PEM certificate chain</li>
<li><code>key-file</code> &ndash; path to the PEM private key</li>
</ul>

<p>
The TCP-based <code>HTTPListener</code> continues to use the standard Java
keystore properties (<code>keystore-file</code>, <code>keystore-pass</code>,
<code>keystore-format</code>). If you have a PKCS#12 keystore, you can
extract PEM files with OpenSSL:
</p>

<pre>
openssl pkcs12 -in keystore.p12 -nokeys -out cert.pem
openssl pkcs12 -in keystore.p12 -nocerts -nodes -out key.pem
</pre>

<h4>Alt-Svc Discovery</h4>

<p>
When an <code>HTTPService</code> has both TCP and QUIC listeners, it
automatically computes an <code>Alt-Svc</code> response header and injects it
into HTTP/1.1 and HTTP/2 responses served by the TCP listener. This tells
clients that HTTP/3 is available:
</p>

<pre>
alt-svc: h3=":443"
</pre>

<p>
Clients that support HTTP/3 (all major browsers, curl, etc.) will attempt to
use QUIC on subsequent requests. If the QUIC connection fails or is not
supported by the network, clients fall back to HTTP/2 or HTTP/1.1
transparently.
</p>

<h4>HTTP3Listener Properties</h4>

<ul>
<li><code>port</code> &ndash; UDP listening port (default: 443)</li>
<li><code>cert-file</code> &ndash; path to PEM certificate chain (required)</li>
<li><code>key-file</code> &ndash; path to PEM private key (required)</li>
</ul>

<h3 id="http2">HTTP/2 Support</h3>

<p>
Gumdrop's HTTP/2 implementation provides all mandatory features of
RFC 7540 plus several optional features.
</p>

<h4>Frame Types</h4>

<p>
All HTTP/2 frame types are supported:
</p>
<ul>
<li><b>DATA</b> - request and response body content</li>
<li><b>HEADERS</b> - header blocks with optional priority</li>
<li><b>PRIORITY</b> - stream dependency and weight updates</li>
<li><b>RST_STREAM</b> - stream termination</li>
<li><b>SETTINGS</b> - connection-level configuration exchange</li>
<li><b>PUSH_PROMISE</b> - server push initiation</li>
<li><b>PING</b> - connection liveness checks</li>
<li><b>GOAWAY</b> - graceful connection shutdown</li>
<li><b>WINDOW_UPDATE</b> - flow control</li>
<li><b>CONTINUATION</b> - header block continuation</li>
</ul>

<h4>HPACK Header Compression</h4>

<p>
Gumdrop includes a complete HPACK implementation (RFC 7541) for HTTP/2
header compression:
</p>
<ul>
<li><b>Static table</b> - 61 pre-defined header entries for common headers
like <code>:method</code>, <code>:path</code>, <code>:status</code>, etc.</li>
<li><b>Dynamic table</b> - per-connection header index that adapts to
application-specific headers</li>
<li><b>Huffman encoding</b> - optional string compression using the HPACK
Huffman code table</li>
<li><b>Indexed header fields</b> - efficient encoding of repeated headers</li>
</ul>

<p>
The HPACK encoder and decoder maintain separate dynamic tables for each
direction of communication, with configurable maximum table sizes.
</p>

<h4>Frame Padding</h4>

<p>
For security-sensitive applications, HTTP/2 frame padding can be enabled
to obscure message sizes. Padding adds random-length padding to DATA,
HEADERS, and PUSH_PROMISE frames (RFC 7540 Section 6.1).
</p>

<pre>
&lt;service class="org.bluezoo.gumdrop.http.HTTPService"&gt;
  &lt;listener class="org.bluezoo.gumdrop.http.HTTPListener"&gt;
    &lt;property name="port"&gt;443&lt;/property&gt;
    &lt;property name="secure"&gt;true&lt;/property&gt;
    &lt;property name="frame-padding"&gt;64&lt;/property&gt;
  &lt;/listener&gt;
&lt;/service&gt;
</pre>

<h4>Priority-Aware Server</h4>

<p>
The <code>PriorityAwareHTTPServer</code> extends the base HTTP server with
sophisticated HTTP/2 stream priority handling. This is beneficial for
complex web applications serving multiple resource types (HTML, CSS, JS,
images, API responses).
</p>

<p>
Features of the priority-aware server:
</p>
<ul>
<li><b>Priority-based scheduling</b> - processes high-priority streams first</li>
<li><b>Bandwidth allocation</b> - distributes resources based on stream weights</li>
<li><b>Starvation prevention</b> - ensures low-priority streams receive fair
access through configurable time slices</li>
<li><b>Dependency tree</b> - respects HTTP/2 priority dependency relationships</li>
</ul>

<p>
Configuration properties:
</p>
<ul>
<li><code>min-low-priority-time-slice</code> - minimum milliseconds before starved
streams are promoted (default: 100)</li>
<li><code>max-high-priority-burst</code> - maximum consecutive operations for
high-priority streams before yielding (default: 10)</li>
<li><code>priority-logging</code> - enable detailed scheduling logs</li>
</ul>

<p>
The priority-aware server adds approximately 6-10KB memory overhead per
connection and 5-10% CPU overhead under load. For simple file servers or
single-resource APIs, the standard <code>HTTPServer</code> is sufficient.
</p>

<h3 id="server-handler">Server Handler API</h3>

<p>
Gumdrop provides an event-driven, non-blocking API for building HTTP servers.
The API abstracts away HTTP version details (HTTP/3, HTTP/2, and HTTP/1.1),
allowing handlers to focus on application logic while the framework handles
framing, header compression, flow control, and connection management.
</p>

<h4>Core Interfaces</h4>

<p>
The server handler API consists of three main interfaces:
</p>

<ul>
<li><b>HTTPRequestHandlerFactory</b> - creates handlers for incoming requests,
enabling routing based on path, method, or other headers</li>
<li><b>HTTPRequestHandler</b> - receives request events (headers, body chunks,
completion) for a single stream</li>
<li><b>HTTPResponseState</b> - provided to handlers for sending responses</li>
</ul>

<h4>Event Sequence</h4>

<p>
Request handlers receive events in a well-defined order:
</p>

<pre>
headers()              // request headers (:method, :path, etc.)
startRequestBody()     // if request has a body
requestBodyContent()   // one or more body chunks
endRequestBody()       // body complete
headers()              // trailer headers (if any)
requestComplete()      // stream closed from client
</pre>

<p>
For requests without a body (GET, HEAD, etc.):
</p>

<pre>
headers()              // request headers with END_STREAM
requestComplete()
</pre>

<h4>Sending Responses</h4>

<p>
The <code>HTTPResponseState</code> interface provides methods for building
responses:
</p>

<pre>
headers()              // response headers (includes :status)
startResponseBody()    // if response has a body
responseBodyContent()  // one or more body chunks
endResponseBody()      // body complete
headers()              // trailer headers (optional)
complete()             // finish the response
</pre>

<h4>Example: Hello World Handler</h4>

<pre>
public class HelloHandler extends DefaultHTTPRequestHandler {
    
    @Override
    public void headers(HTTPResponseState state, Headers headers) {
        if ("GET".equals(headers.getMethod())) {
            Headers response = new Headers();
            response.status(HTTPStatus.OK);
            response.add("content-type", "text/plain");
            state.headers(response);
            state.startResponseBody();
            state.responseBodyContent(
                ByteBuffer.wrap("Hello, World!".getBytes()));
            state.endResponseBody();
            state.complete();
        }
    }
}
</pre>

<h4>Request Routing with Factory</h4>

<p>
The factory receives initial headers before the handler is created, enabling
routing decisions based on path, method, or other criteria:
</p>

<pre>
public class MyFactory implements HTTPRequestHandlerFactory {
    
    public HTTPRequestHandler createHandler(HTTPResponseState state,
                                            Headers headers) {
        String path = headers.getPath();
        
        if (path.startsWith("/api/")) {
            return new ApiHandler();
        } else if (path.startsWith("/static/")) {
            return new StaticFileHandler(documentRoot);
        } else {
            return new DefaultHandler();
        }
    }
}
</pre>

<h4>Programmatic Setup</h4>

<p>
Set the handler factory on the service:
</p>

<pre>
HTTPService service = new HTTPService();
service.setHandlerFactory(new MyFactory());

HTTPListener listener = new HTTPListener();
listener.setPort(8080);
service.addListener(listener);
service.start();
</pre>

<h4>Authentication</h4>

<p>
If a <code>Realm</code> is configured on the service, authentication is
performed automatically before the factory is called. The authenticated
principal is available via <code>HTTPResponseState.getPrincipal()</code>.
</p>

<p>
Alternatively, the factory can perform authentication manually:
</p>

<pre>
public HTTPRequestHandler createHandler(HTTPResponseState state,
                                        Headers headers) {
    String auth = headers.getValue("authorization");
    if (!isValidAuth(auth)) {
        Headers response = new Headers();
        response.status(HTTPStatus.UNAUTHORIZED);
        response.add("www-authenticate", "Bearer");
        state.headers(response);
        state.complete();
        return null;  // no handler needed
    }
    return new MyHandler();
}
</pre>

<h4>HTTP/2 Server Push</h4>

<p>
For HTTP/2 connections, handlers can initiate server push to proactively
send resources to the client:
</p>

<pre>
@Override
public void headers(HTTPResponseState state, Headers headers) {
    // Push a stylesheet that we know the client will need
    Headers pushHeaders = new Headers();
    pushHeaders.add(":method", "GET");
    pushHeaders.add(":path", "/styles/main.css");
    pushHeaders.add(":scheme", state.getScheme());
    pushHeaders.add(":authority", headers.getValue(":authority"));
    
    if (state.pushPromise(pushHeaders)) {
        // Push was accepted; the pushed stream will be processed
        // through the factory like any other request
    }
    
    // Continue with the normal response...
}
</pre>

<p>
Server push returns <code>false</code> for HTTP/1.x connections or if
the client has disabled push via settings.
</p>

<h4>Endpoint Information</h4>

<p>
The <code>HTTPResponseState</code> provides access to endpoint details:
</p>

<ul>
<li><code>getEndpoint()</code> - the underlying endpoint (remote/local addresses)</li>
<li><code>getSecurityInfo()</code> - TLS session details (null if not secure)</li>
<li><code>getVersion()</code> - HTTP version (HTTP_3, HTTP_2, HTTP_1_1, HTTP_1_0)</li>
<li><code>getScheme()</code> - URL scheme ("http" or "https")</li>
<li><code>getPrincipal()</code> - authenticated user (if Realm configured)</li>
</ul>

<h4>Streaming Responses</h4>

<p>
For server-sent events or other streaming scenarios:
</p>

<pre>
public class StreamHandler extends DefaultHTTPRequestHandler {
    
    @Override
    public void headers(HTTPResponseState state, Headers headers) {
        Headers response = new Headers();
        response.status(HTTPStatus.OK);
        response.add("content-type", "text/event-stream");
        state.headers(response);
        state.startResponseBody();
        
        // Keep reference to state for async sends
        eventEmitter.subscribe(event -> {
            state.responseBodyContent(
                ByteBuffer.wrap(event.toSSE().getBytes()));
        });
    }
}
</pre>

<h4>Error Handling</h4>

<p>
Use <code>cancel()</code> to abort a stream on error:
</p>

<pre>
@Override
public void requestBodyContent(HTTPResponseState state, ByteBuffer data) {
    if (data.remaining() > MAX_BODY_SIZE) {
        Headers response = new Headers();
        response.status(HTTPStatus.REQUEST_ENTITY_TOO_LARGE);
        state.headers(response);
        state.complete();
        state.cancel();  // abort the stream
    }
}
</pre>

<h3 id="upgrades">Protocol Upgrades</h3>

<h4>HTTP/2 Cleartext Upgrade (h2c)</h4>

<p>
For non-TLS connections, HTTP/2 can be negotiated via the HTTP/1.1 Upgrade
mechanism. The client sends:
</p>

<pre>
GET / HTTP/1.1
Host: example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
</pre>

<p>
If the server supports HTTP/2, it responds with 101 Switching Protocols
and both sides switch to HTTP/2 framing:
</p>

<pre>
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: h2c
</pre>

<p>
The <code>HTTP2-Settings</code> header contains base64url-encoded SETTINGS
frame payload, allowing the client to communicate initial settings before
the upgrade completes.
</p>

<h3 id="configuration">Configuration</h3>

<h4>HTTPListener Properties</h4>

<p>
<code>HTTPListener</code> is the TCP listener for HTTP/1.1 and HTTP/2. It
inherits standard listener properties and adds HTTP-specific options:
</p>

<ul>
<li><code>port</code> &ndash; listening port (default: 80, or 443 for secure)</li>
<li><code>secure</code> &ndash; enable implicit TLS</li>
<li><code>keystore-file</code> &ndash; path to keystore for TLS</li>
<li><code>keystore-pass</code> &ndash; keystore password</li>
<li><code>keystore-format</code> &ndash; keystore format (default: PKCS12)</li>
<li><code>need-client-auth</code> &ndash; require client certificates</li>
<li><code>frame-padding</code> &ndash; HTTP/2 frame padding (0&ndash;255 bytes)</li>
<li><code>authentication-provider</code> &ndash; HTTP authentication configuration</li>
</ul>

<h4>HTTP3Listener Properties</h4>

<p>
<code>HTTP3Listener</code> is the QUIC listener for HTTP/3. Because QUIC
uses BoringSSL rather than the JDK TLS stack, certificate configuration
uses PEM files instead of a keystore:
</p>

<ul>
<li><code>port</code> &ndash; UDP listening port (default: 443)</li>
<li><code>cert-file</code> &ndash; path to PEM certificate chain (required)</li>
<li><code>key-file</code> &ndash; path to PEM private key (required)</li>
</ul>

<h4>Combined HTTP/3 + HTTP/2 + HTTP/1.1</h4>

<p>
A typical production configuration exposes both TCP (HTTP/1.1, HTTP/2) and
QUIC (HTTP/3) on the same port number. The TCP listener handles traditional
connections while the QUIC listener handles HTTP/3 connections on UDP. The
service automatically sets the <code>Alt-Svc</code> header on TCP responses
so that clients can discover and migrate to HTTP/3:
</p>

<pre>
&lt;service id="web" class="org.bluezoo.gumdrop.servlet.ServletService"&gt;
  &lt;listener class="org.bluezoo.gumdrop.http.HTTPListener"&gt;
    &lt;property name="port"&gt;443&lt;/property&gt;
    &lt;property name="secure"&gt;true&lt;/property&gt;
    &lt;property name="keystore-file"&gt;keystore.p12&lt;/property&gt;
    &lt;property name="keystore-pass"&gt;changeit&lt;/property&gt;
  &lt;/listener&gt;
  &lt;listener class="org.bluezoo.gumdrop.http.h3.HTTP3Listener"&gt;
    &lt;property name="port"&gt;443&lt;/property&gt;
    &lt;property name="cert-file"&gt;cert.pem&lt;/property&gt;
    &lt;property name="key-file"&gt;key.pem&lt;/property&gt;
  &lt;/listener&gt;
&lt;/service&gt;
</pre>

<h4>Authentication</h4>

<p>
Gumdrop supports HTTP authentication methods:
</p>
<ul>
<li><b>Basic</b> - RFC 7617 basic authentication</li>
<li><b>Digest</b> - RFC 7616 digest authentication</li>
<li><b>Bearer</b> - RFC 6750 bearer token authentication</li>
<li><b>OAuth</b> - OAuth 2.0 integration</li>
</ul>

<p>
Authentication is configured via an <code>HTTPAuthenticationProvider</code>
which can be shared across multiple services or customised per service. It is
integrated into the centralised <code>org.bluezoo.gumdrop.auth.Realm</code>-based
facility for managing authentication and authorisation across all services
running in the framework.
</p>

<h3 id="client">HTTP Client</h3>

<p>
Gumdrop includes a non-blocking HTTP client that shares the same event-driven
architecture as the server. The client supports HTTP/3, HTTP/2, and HTTP/1.1
with automatic protocol negotiation.
</p>

<h4>SelectorLoop Affinity</h4>

<p>
When an HTTP client connection is initiated by a Gumdrop server connection,
it can be assigned to the same Gumdrop worker SelectorLoop as is used by
used by the server connection. This provides several advantages:
</p>

<ul>
<li><b>Unified I/O model</b> - client and server connections share the same
non-blocking infrastructure, avoiding thread context switches and complex
race conditions when making outbound requests from within server handlers</li>
<li><b>Connection affinity</b> - once assigned, a client connection remains
bound to its worker thread for the duration of its lifecycle, eliminating
race conditions</li>
<li><b>Resource efficiency</b> - no additional thread pools are required for
client connections; they multiplex with server I/O on the existing workers</li>
<li><b>TLS integration</b> - SSL handshakes and encryption are handled inline
on the assigned worker, just as with server connections</li>
</ul>

<p>
This makes the HTTP client particularly well-suited for server-side use cases
such as proxying, service-to-service communication, and telemetry export
where the client operates within the context of an existing Gumdrop server.
</p>

<p>
The existing OpenTelemetry implementation within Gumdrop uses this exact
mechanism for efficiency, and server processes that need to call REST
endpoints, for instance, can easily benefit from high performance asynchronous
non-blocking connections to them via this feature.
</p>

<h4>Features</h4>

<ul>
<li><b>Asynchronous operation</b> &ndash; integrates with Gumdrop&rsquo;s SelectorLoop</li>
<li><b>HTTP/3 support</b> &ndash; QUIC transport with ALPN &ldquo;h3&rdquo;</li>
<li><b>HTTP/2 support</b> &ndash; ALPN negotiation for TLS, h2c upgrade for
plaintext</li>
<li><b>Stream multiplexing</b> &ndash; concurrent requests over a single HTTP/2
or HTTP/3 connection</li>
<li><b>Authentication</b> &ndash; Basic, Digest, Bearer, and OAuth support</li>
<li><b>Automatic retry</b> &ndash; authentication challenges handled
transparently</li>
</ul>

<h4>Usage (HTTP/2 and HTTP/1.1)</h4>

<pre>
HTTPClient client = new HTTPClient("example.com", 443);
client.setSecure(true);

client.connect(new HTTPClientHandler() {
    public void onConnected(Endpoint endpoint) {
        HTTPRequest request = client.get("/api/data");
        request.header("Accept", "application/json");
        request.send(new DefaultHTTPResponseHandler() {
            public void ok(HTTPResponse response) {
                System.out.println("Status: " + response.getStatus());
            }
            public void responseBodyContent(ByteBuffer data) {
                // Process response body
            }
            public void close() {
                System.out.println("Response complete");
                client.close();
            }
            public void failed(Exception ex) {
                ex.printStackTrace();
            }
        });
    }
    public void onSecurityEstablished(SecurityInfo info) { }
    public void onError(Exception cause) { cause.printStackTrace(); }
    public void onDisconnected() { }
});
</pre>

<h4>Usage (HTTP/3)</h4>

<p>
To use HTTP/3, enable it on the client before connecting. The client uses
QUIC with ALPN &ldquo;h3&rdquo; instead of TCP:
</p>

<pre>
HTTPClient client = new HTTPClient("example.com", 443);
client.setH3Enabled(true);

client.connect(new HTTPClientHandler() {
    public void onConnected(Endpoint endpoint) {
        HTTPRequest request = client.get("/api/data");
        request.header("Accept", "application/json");
        request.send(responseHandler);
    }
    public void onSecurityEstablished(SecurityInfo info) { }
    public void onError(Exception cause) { cause.printStackTrace(); }
    public void onDisconnected() { }
});
</pre>

<p>
The request and response APIs are identical regardless of the underlying
protocol version. The only difference is how the client is configured
before connecting.
</p>

<p>
All handler callbacks are invoked on the client connection&rsquo;s assigned
worker thread. Long-running operations within handlers should be offloaded
to avoid blocking the SelectorLoop.
</p>

<hr/>

<p>
<a href="index.html">&larr; Back to Main Page</a> |
<a href="webdav.html">File Server &amp; WebDAV</a> |
<a href="websocket.html">WebSocket Service &amp; Client</a> |
<a href="smtp.html">SMTP Server &amp; Client</a> |
<a href="imap.html">IMAP Server</a> |
<a href="pop3.html">POP3 Server</a> |
<a href="dns.html">DNS Server</a> |
<a href="telemetry.html">Telemetry</a>
</p>

<p class='server-info'>Gumdrop HTTP Server</p>

</body>
</html>

