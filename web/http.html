<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "xhtml11.dtd">
<!--
  This file is part of gumdrop.

  gumdrop is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  gumdrop is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with gumdrop; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico"/>
<link rel="SHORTCUT ICON" href="favicon.ico"/>
<title>HTTP Server &amp; Client - Gumdrop</title>
</head>
<body>

<table summary='(layout)'>
<tr>
<td>
<img align="left" border="0" src="gumdrop.png" alt="(gumdrop)" />
</td>
<td valign='bottom'>
<h1 class='offset'>Gumdrop HTTP Server &amp; Client</h1>
</td>
</table>

<p><a href="index.html">&larr; Back to Main Page</a></p>

<p>
Gumdrop provides a comprehensive HTTP implementation supporting modern
protocol versions and features. The HTTP layer serves as the foundation
for higher-level services including the <a href="servlet.html">servlet
container</a> and static file server.
</p>

<h3>Contents</h3>
<ul>
<li><a href="#versions">HTTP Versions</a></li>
<li><a href="#http2">HTTP/2 Support</a></li>
<li><a href="#server-handler">Server Handler API</a></li>
<li><a href="#websocket">WebSocket Support</a></li>
<li><a href="#upgrades">Protocol Upgrades</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#client">HTTP Client</a></li>
<li><a href="#file-server">File HTTP Server</a></li>
<li><a href="#webdav">WebDAV Support</a></li>
</ul>

<h3 id="versions">HTTP Versions</h3>

<p>
Gumdrop supports HTTP/1.0, HTTP/1.1, and HTTP/2 protocols, with automatic
version detection and negotiation. Originally built to support HTTP/1.1
as a native protocol, Gumdrop was first adapted to use the SPDY protocol
developed by Google, and then, as that was deprecated and consensus
established on the newer HTTP/2 protocol, Gumdrop embraced the efficiency
and extensibility of the latter and promotes its usage.
</p>

<h4>HTTP/1.0</h4>

<p>
Basic HTTP support for legacy clients. Connections are closed after each
request/response unless explicitly kept alive.
</p>

<h4>HTTP/1.1</h4>

<p>
Full HTTP/1.1 support including:
</p>
<ul>
<li><b>Persistent connections</b> - connections remain open for multiple
request/response cycles by default</li>
<li><b>Chunked transfer encoding</b> - streaming of request and response
bodies without a priori content length</li>
<li><b>Host header requirement</b> - virtual hosting support</li>
<li><b>Pipelining</b> - multiple requests can be sent without waiting for
responses (though this is rarely used in practice)</li>
</ul>

<h4>HTTP/2</h4>

<p>
Complete HTTP/2 implementation (RFC 7540) with multiplexing and header
compression. HTTP/2 can be negotiated via ALPN during TLS handshake or
via cleartext upgrade (h2c).
</p>

<h3 id="http2">HTTP/2 Support</h3>

<p>
Gumdrop's HTTP/2 implementation provides all mandatory features of
RFC 7540 plus several optional features.
</p>

<h4>Frame Types</h4>

<p>
All HTTP/2 frame types are supported:
</p>
<ul>
<li><b>DATA</b> - request and response body content</li>
<li><b>HEADERS</b> - header blocks with optional priority</li>
<li><b>PRIORITY</b> - stream dependency and weight updates</li>
<li><b>RST_STREAM</b> - stream termination</li>
<li><b>SETTINGS</b> - connection-level configuration exchange</li>
<li><b>PUSH_PROMISE</b> - server push initiation</li>
<li><b>PING</b> - connection liveness checks</li>
<li><b>GOAWAY</b> - graceful connection shutdown</li>
<li><b>WINDOW_UPDATE</b> - flow control</li>
<li><b>CONTINUATION</b> - header block continuation</li>
</ul>

<h4>HPACK Header Compression</h4>

<p>
Gumdrop includes a complete HPACK implementation (RFC 7541) for HTTP/2
header compression:
</p>
<ul>
<li><b>Static table</b> - 61 pre-defined header entries for common headers
like <code>:method</code>, <code>:path</code>, <code>:status</code>, etc.</li>
<li><b>Dynamic table</b> - per-connection header index that adapts to
application-specific headers</li>
<li><b>Huffman encoding</b> - optional string compression using the HPACK
Huffman code table</li>
<li><b>Indexed header fields</b> - efficient encoding of repeated headers</li>
</ul>

<p>
The HPACK encoder and decoder maintain separate dynamic tables for each
direction of communication, with configurable maximum table sizes.
</p>

<h4>Frame Padding</h4>

<p>
For security-sensitive applications, HTTP/2 frame padding can be enabled
to obscure message sizes. Padding adds random-length padding to DATA,
HEADERS, and PUSH_PROMISE frames (RFC 7540 Section 6.1).
</p>

<pre>
&lt;server class="org.bluezoo.gumdrop.http.HTTPServer"&gt;
  &lt;property name="port"&gt;443&lt;/property&gt;
  &lt;property name="secure"&gt;true&lt;/property&gt;
  &lt;property name="frame-padding"&gt;64&lt;/property&gt;
&lt;/server&gt;
</pre>

<h4>Priority-Aware Server</h4>

<p>
The <code>PriorityAwareHTTPServer</code> extends the base HTTP server with
sophisticated HTTP/2 stream priority handling. This is beneficial for
complex web applications serving multiple resource types (HTML, CSS, JS,
images, API responses).
</p>

<p>
Features of the priority-aware server:
</p>
<ul>
<li><b>Priority-based scheduling</b> - processes high-priority streams first</li>
<li><b>Bandwidth allocation</b> - distributes resources based on stream weights</li>
<li><b>Starvation prevention</b> - ensures low-priority streams receive fair
access through configurable time slices</li>
<li><b>Dependency tree</b> - respects HTTP/2 priority dependency relationships</li>
</ul>

<p>
Configuration properties:
</p>
<ul>
<li><code>min-low-priority-time-slice</code> - minimum milliseconds before starved
streams are promoted (default: 100)</li>
<li><code>max-high-priority-burst</code> - maximum consecutive operations for
high-priority streams before yielding (default: 10)</li>
<li><code>priority-logging</code> - enable detailed scheduling logs</li>
</ul>

<p>
The priority-aware server adds approximately 6-10KB memory overhead per
connection and 5-10% CPU overhead under load. For simple file servers or
single-resource APIs, the standard <code>HTTPServer</code> is sufficient.
</p>

<h3 id="server-handler">Server Handler API</h3>

<p>
Gumdrop provides an event-driven, non-blocking API for building HTTP servers.
The API abstracts away HTTP version details (HTTP/1.1 vs HTTP/2), allowing
handlers to focus on application logic while the framework handles framing,
header compression, flow control, and connection management.
</p>

<h4>Core Interfaces</h4>

<p>
The server handler API consists of three main interfaces:
</p>

<ul>
<li><b>HTTPRequestHandlerFactory</b> - creates handlers for incoming requests,
enabling routing based on path, method, or other headers</li>
<li><b>HTTPRequestHandler</b> - receives request events (headers, body chunks,
completion) for a single stream</li>
<li><b>HTTPResponseState</b> - provided to handlers for sending responses</li>
</ul>

<h4>Event Sequence</h4>

<p>
Request handlers receive events in a well-defined order:
</p>

<pre>
headers()              // request headers (:method, :path, etc.)
startRequestBody()     // if request has a body
requestBodyContent()   // one or more body chunks
endRequestBody()       // body complete
headers()              // trailer headers (if any)
requestComplete()      // stream closed from client
</pre>

<p>
For requests without a body (GET, HEAD, etc.):
</p>

<pre>
headers()              // request headers with END_STREAM
requestComplete()
</pre>

<h4>Sending Responses</h4>

<p>
The <code>HTTPResponseState</code> interface provides methods for building
responses:
</p>

<pre>
headers()              // response headers (includes :status)
startResponseBody()    // if response has a body
responseBodyContent()  // one or more body chunks
endResponseBody()      // body complete
headers()              // trailer headers (optional)
complete()             // finish the response
</pre>

<h4>Example: Hello World Handler</h4>

<pre>
public class HelloHandler extends DefaultHTTPRequestHandler {
    
    @Override
    public void headers(Headers headers, HTTPResponseState state) {
        if ("GET".equals(headers.getMethod())) {
            Headers response = new Headers();
            response.status(HTTPStatus.OK);
            response.add("content-type", "text/plain");
            state.headers(response);
            state.startResponseBody();
            state.responseBodyContent(
                ByteBuffer.wrap("Hello, World!".getBytes()));
            state.endResponseBody();
            state.complete();
        }
    }
}
</pre>

<h4>Request Routing with Factory</h4>

<p>
The factory receives initial headers before the handler is created, enabling
routing decisions based on path, method, or other criteria:
</p>

<pre>
public class MyFactory implements HTTPRequestHandlerFactory {
    
    public HTTPRequestHandler createHandler(Headers headers, 
                                            HTTPResponseState state) {
        String path = headers.getPath();
        
        if (path.startsWith("/api/")) {
            return new ApiHandler();
        } else if (path.startsWith("/static/")) {
            return new StaticFileHandler(documentRoot);
        } else {
            return new DefaultHandler();
        }
    }
}
</pre>

<h4>Server Configuration</h4>

<p>
Set the handler factory on the server:
</p>

<pre>
HTTPServer server = new HTTPServer();
server.setPort(8080);
server.setHandlerFactory(new MyFactory());
server.start();
</pre>

<h4>Authentication</h4>

<p>
If a <code>Realm</code> is configured on the server, authentication is
performed automatically before the factory is called. The authenticated
principal is available via <code>HTTPResponseState.getPrincipal()</code>.
</p>

<p>
Alternatively, the factory can perform authentication manually:
</p>

<pre>
public HTTPRequestHandler createHandler(Headers headers, 
                                        HTTPResponseState state) {
    String auth = headers.getValue("authorization");
    if (!isValidAuth(auth)) {
        Headers response = new Headers();
        response.status(HTTPStatus.UNAUTHORIZED);
        response.add("www-authenticate", "Bearer");
        state.headers(response);
        state.complete();
        return null;  // no handler needed
    }
    return new MyHandler();
}
</pre>

<h4>HTTP/2 Server Push</h4>

<p>
For HTTP/2 connections, handlers can initiate server push to proactively
send resources to the client:
</p>

<pre>
@Override
public void headers(Headers headers, HTTPResponseState state) {
    // Push a stylesheet that we know the client will need
    Headers pushHeaders = new Headers();
    pushHeaders.add(":method", "GET");
    pushHeaders.add(":path", "/styles/main.css");
    pushHeaders.add(":scheme", state.getScheme());
    pushHeaders.add(":authority", headers.getValue(":authority"));
    
    if (state.pushPromise(pushHeaders)) {
        // Push was accepted; the pushed stream will be processed
        // through the factory like any other request
    }
    
    // Continue with the normal response...
}
</pre>

<p>
Server push returns <code>false</code> for HTTP/1.x connections or if
the client has disabled push via settings.
</p>

<h4>Connection Information</h4>

<p>
The <code>HTTPResponseState</code> provides access to connection details:
</p>

<ul>
<li><code>getConnectionInfo()</code> - remote/local addresses, connection ID</li>
<li><code>getTLSInfo()</code> - TLS session details (null if not secure)</li>
<li><code>getVersion()</code> - HTTP version (HTTP_1_0, HTTP_1_1, HTTP_2)</li>
<li><code>getScheme()</code> - URL scheme ("http" or "https")</li>
<li><code>getPrincipal()</code> - authenticated user (if Realm configured)</li>
</ul>

<h4>Streaming Responses</h4>

<p>
For server-sent events or other streaming scenarios:
</p>

<pre>
public class StreamHandler extends DefaultHTTPRequestHandler {
    
    @Override
    public void headers(Headers headers, HTTPResponseState state) {
        Headers response = new Headers();
        response.status(HTTPStatus.OK);
        response.add("content-type", "text/event-stream");
        state.headers(response);
        state.startResponseBody();
        
        // Keep reference to state for async sends
        eventEmitter.subscribe(event -> {
            state.responseBodyContent(
                ByteBuffer.wrap(event.toSSE().getBytes()));
        });
    }
}
</pre>

<h4>Error Handling</h4>

<p>
Use <code>cancel()</code> to abort a stream on error:
</p>

<pre>
@Override
public void requestBodyContent(ByteBuffer data, HTTPResponseState state) {
    if (data.remaining() > MAX_BODY_SIZE) {
        Headers response = new Headers();
        response.status(HTTPStatus.REQUEST_ENTITY_TOO_LARGE);
        state.headers(response);
        state.complete();
        state.cancel();  // abort the stream
    }
}
</pre>

<h3 id="websocket">WebSocket Support</h3>

<p>
Gumdrop supports WebSocket protocol upgrades per RFC 6455, integrated with
the HTTP server handler API.
</p>

<h4>WebSocket Handshake</h4>

<p>
A WebSocket upgrade request looks like:
</p>

<pre>
GET /websocket HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
</pre>

<p>
The server validates the request and computes the accept value by
concatenating the client's key with the WebSocket GUID and hashing
with SHA-1:
</p>

<pre>
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</pre>

<h4>WebSocket Handler API</h4>

<p>
The WebSocket API uses event handlers similar to the HTTP API:
</p>

<ul>
<li><b>WebSocketEventHandler</b> - receives connection events (opened, closed,
error) and messages (text, binary)</li>
<li><b>WebSocketSession</b> - provided to the handler for sending messages</li>
</ul>

<h4>Upgrading from HTTP</h4>

<p>
Use <code>HTTPResponseState.upgradeToWebSocket()</code> in your HTTP handler:
</p>

<pre>
public class MyHandler extends DefaultHTTPRequestHandler {
    
    @Override
    public void headers(Headers headers, HTTPResponseState state) {
        if (WebSocketHandshake.isValidWebSocketUpgrade(headers)) {
            String protocol = headers.getValue("Sec-WebSocket-Protocol");
            state.upgradeToWebSocket(protocol, new EchoWebSocketHandler());
        } else {
            // Handle as regular HTTP request
        }
    }
}
</pre>

<h4>WebSocket Event Handler Example</h4>

<pre>
public class EchoWebSocketHandler extends DefaultWebSocketEventHandler {
    private WebSocketSession session;
    
    @Override
    public void opened(WebSocketSession session) {
        this.session = session;
    }
    
    @Override
    public void textMessageReceived(String message) {
        try {
            session.sendText("Echo: " + message);
        } catch (IOException e) {
            // Handle error
        }
    }
    
    @Override
    public void binaryMessageReceived(ByteBuffer data) {
        try {
            session.sendBinary(data);
        } catch (IOException e) {
            // Handle error
        }
    }
    
    @Override
    public void closed(int code, String reason) {
        // Clean up resources
    }
    
    @Override
    public void error(Throwable cause) {
        cause.printStackTrace();
    }
}
</pre>

<h4>WebSocket Session Methods</h4>

<ul>
<li><code>sendText(String message)</code> - send a text message</li>
<li><code>sendBinary(ByteBuffer data)</code> - send binary data</li>
<li><code>sendPing(ByteBuffer payload)</code> - send a ping frame</li>
<li><code>close()</code> - close with normal status (1000)</li>
<li><code>close(int code, String reason)</code> - close with specific status</li>
<li><code>isOpen()</code> - check if session is still active</li>
</ul>

<h4>Subprotocol Negotiation</h4>

<p>
The client may request specific subprotocols via
<code>Sec-WebSocket-Protocol</code>. Pass the selected subprotocol to
<code>upgradeToWebSocket()</code>:
</p>

<pre>
String requested = headers.getValue("Sec-WebSocket-Protocol");
String selected = negotiateProtocol(requested);  // your logic
state.upgradeToWebSocket(selected, handler);
</pre>

<h3 id="upgrades">Protocol Upgrades</h3>

<h4>HTTP/2 Cleartext Upgrade (h2c)</h4>

<p>
For non-TLS connections, HTTP/2 can be negotiated via the HTTP/1.1 Upgrade
mechanism. The client sends:
</p>

<pre>
GET / HTTP/1.1
Host: example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
</pre>

<p>
If the server supports HTTP/2, it responds with 101 Switching Protocols
and both sides switch to HTTP/2 framing:
</p>

<pre>
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: h2c
</pre>

<p>
The <code>HTTP2-Settings</code> header contains base64url-encoded SETTINGS
frame payload, allowing the client to communicate initial settings before
the upgrade completes.
</p>

<h3 id="configuration">Configuration</h3>

<h4>HTTPServer Properties</h4>

<p>
<code>org.bluezoo.gumdrop.http.HTTPServer</code> is the base class for HTTP
servers. All subclasses inherit these properties:
</p>

<ul>
<li><code>port</code> - listening port (default: 80 or 443 for secure)</li>
<li><code>secure</code> - enable implicit TLS</li>
<li><code>keystoreFile</code> - path to keystore for TLS</li>
<li><code>keystorePass</code> - keystore password</li>
<li><code>keystoreFormat</code> - keystore format (default: PKCS12)</li>
<li><code>needClientAuth</code> - require client certificates</li>
<li><code>framePadding</code> - HTTP/2 frame padding (0-255 bytes)</li>
<li><code>authenticationProvider</code> - HTTP authentication configuration</li>
</ul>

<h4>Authentication</h4>

<p>
Gumdrop supports HTTP authentication methods:
</p>
<ul>
<li><b>Basic</b> - RFC 7617 basic authentication</li>
<li><b>Digest</b> - RFC 7616 digest authentication</li>
<li><b>Bearer</b> - RFC 6750 bearer token authentication</li>
<li><b>OAuth</b> - OAuth 2.0 integration</li>
</ul>

<p>
Authentication is configured via an <code>HTTPAuthenticationProvider</code>
which can be shared across multiple servers or customised per server. It is
integrated into the centralised <code>org.bluezoo.gumdrop.auth.Realm</code>-based
facility for managing authentication and authorisation across all servers
and servlet containers running in the framework.
</p>

<h3 id="client">HTTP Client</h3>

<p>
Gumdrop includes a non-blocking HTTP client that shares the same event-driven
architecture as the server. The client supports HTTP/1.1 and HTTP/2 with
automatic protocol negotiation.
</p>

<h4>SelectorLoop Affinity</h4>

<p>
When an HTTP client connection is initiated by a Gumdrop server connection,
it can be assigned to the same Gumdrop worker SelectorLoop as is used by
used by the server connection. This provides several advantages:
</p>

<ul>
<li><b>Unified I/O model</b> - client and server connections share the same
non-blocking infrastructure, avoiding thread context switches and complex
race conditions when making outbound requests from within server handlers</li>
<li><b>Connection affinity</b> - once assigned, a client connection remains
bound to its worker thread for the duration of its lifecycle, eliminating
race conditions</li>
<li><b>Resource efficiency</b> - no additional thread pools are required for
client connections; they multiplex with server I/O on the existing workers</li>
<li><b>TLS integration</b> - SSL handshakes and encryption are handled inline
on the assigned worker, just as with server connections</li>
</ul>

<p>
This makes the HTTP client particularly well-suited for server-side use cases
such as proxying, service-to-service communication, and telemetry export
where the client operates within the context of an existing Gumdrop server.
</p>

<p>
The existing OpenTelemetry implementation within Gumdrop uses this exact
mechanism for efficiency, and server processes that need to call REST
endpoints, for instance, can easily benefit from high performance asynchronous
non-blocking connections to them via this feature.
</p>

<h4>Features</h4>

<ul>
<li><b>Asynchronous operation</b> - integrates with Gumdrop's SelectorLoop</li>
<li><b>HTTP/2 support</b> - ALPN negotiation for TLS, h2c upgrade for plaintext</li>
<li><b>Stream multiplexing</b> - concurrent requests over a single HTTP/2 connection</li>
<li><b>Authentication</b> - Basic, Digest, Bearer, and OAuth support</li>
<li><b>Automatic retry</b> - authentication challenges handled transparently</li>
</ul>

<h4>Usage</h4>

<pre>
// Simple usage - connection established automatically
HTTPClient client = new HTTPClient("example.com", 443);
client.setSecure(true);

HTTPRequest request = client.get("/api/data");
request.header("Accept", "application/json");
request.send(new DefaultHTTPResponseHandler() {
    public void ok(HTTPResponse response) {
        System.out.println("Status: " + response.getStatus());
    }
    public void responseBodyContent(ByteBuffer data) {
        // Process response body
    }
    public void close() {
        System.out.println("Response complete");
        client.close();
    }
    public void failed(Exception ex) {
        // Connection or request error
        ex.printStackTrace();
    }
});
</pre>

<p>
All handler callbacks are invoked on the client connection's assigned worker
thread. Long-running operations within handlers should be offloaded to avoid
blocking the SelectorLoop.
</p>

<h3 id="file-server">File HTTP Server</h3>

<p>
The <code>FileHTTPServer</code> demonstrates a complete, production-ready
HTTP server built on the Gumdrop framework. It serves static files from
a filesystem directory with high performance.
</p>

<h4>Features</h4>

<ul>
<li><b>NIO-based transfers</b> - uses Java NIO for efficient file-to-socket
data transfer</li>
<li><b>Content type detection</b> - automatic MIME type detection based on
file extension</li>
<li><b>Directory listings</b> - configurable welcome file for directory requests</li>
<li><b>HTTP methods</b> - GET, HEAD, and optionally PUT/DELETE for writes</li>
<li><b>Range requests</b> - partial content delivery for large files</li>
<li><b>Conditional requests</b> - ETag and Last-Modified support</li>
<li><b>Path security</b> - prevents directory traversal attacks</li>
</ul>

<h4>Configuration</h4>

<pre>
&lt;server id="files" class="org.bluezoo.gumdrop.http.file.FileHTTPServer"&gt;
  &lt;property name="port"&gt;8080&lt;/property&gt;
  &lt;property name="root-path"&gt;/var/www/html&lt;/property&gt;
  &lt;property name="welcome-file"&gt;index.html&lt;/property&gt;
  &lt;property name="allow-write"&gt;false&lt;/property&gt;
&lt;/server&gt;
</pre>

<p>
Properties:
</p>
<ul>
<li><code>rootPath</code> - filesystem directory to serve (required)</li>
<li><code>welcomeFile</code> - default file for directory requests (default:
<code>index.html</code>)</li>
<li><code>allowWrite</code> - enable PUT and DELETE methods (default:
<code>false</code>)</li>
</ul>

<h4>Security</h4>

<p>
The file server validates all paths to ensure they remain within the
configured root directory. Symbolic links are resolved to their real
paths before access checks. The root path must be a readable directory;
if write operations are enabled, the server logs a warning if the directory
is not writable.
</p>

<h4>Performance</h4>

<p>
File transfers use Java NIO's <code>FileChannel.transferTo()</code> where
possible, enabling zero-copy transfers directly from the filesystem to the
socket. This minimises memory allocation and CPU usage for large file
transfers.
</p>

<p>
For HTTP/2 connections, the file server can benefit from the priority-aware
server when serving mixed content (HTML, CSS, JavaScript, images) by
prioritising critical resources.
</p>

<h3 id="webdav">WebDAV Support</h3>

<p>
The file HTTP server supports WebDAV (RFC 2518) distributed authoring when
enabled via the <code>webdavEnabled</code> property. This allows WebDAV
clients such as Windows Explorer, macOS Finder, or dedicated clients like
Cyberduck to access the file server as a network drive.
</p>

<h4>Enabling WebDAV</h4>

<pre>
&lt;server id="webdav" class="org.bluezoo.gumdrop.http.file.FileHTTPServer"&gt;
  &lt;property name="port"&gt;8080&lt;/property&gt;
  &lt;property name="root-path"&gt;/var/www/dav&lt;/property&gt;
  &lt;property name="allow-write"&gt;true&lt;/property&gt;
  &lt;property name="webdav-enabled"&gt;true&lt;/property&gt;
&lt;/server&gt;
</pre>

<p>
When WebDAV is enabled, the server advertises <code>DAV: 1,2</code> in
OPTIONS responses and supports the following additional HTTP methods:
</p>

<h4>WebDAV Methods</h4>

<ul>
<li><b>PROPFIND</b> - Query properties of resources. Supports
<code>allprop</code>, <code>propname</code>, or specific property requests.
The <code>Depth</code> header controls recursion (0, 1, or infinity).</li>

<li><b>PROPPATCH</b> - Set or remove dead properties on resources.
Live properties (those computed from the filesystem) cannot be modified.</li>

<li><b>MKCOL</b> - Create a new collection (directory). The request must
not have a body. The parent directory must exist.</li>

<li><b>COPY</b> - Copy a resource or collection to a new location. Uses
the <code>Destination</code> header for the target URL. The
<code>Overwrite</code> header controls whether existing resources are
replaced (default: true). For collections, <code>Depth</code> controls
whether children are copied.</li>

<li><b>MOVE</b> - Move a resource or collection. Semantically equivalent
to COPY followed by DELETE. Requires valid lock tokens if resources are
locked.</li>

<li><b>LOCK</b> - Lock a resource to prevent concurrent modifications.
Supports exclusive and shared write locks. Returns an opaque lock token
that must be included in subsequent modifying requests.</li>

<li><b>UNLOCK</b> - Release a lock using its token. The token is passed
in the <code>Lock-Token</code> header.</li>
</ul>

<h4>Live Properties</h4>

<p>
The following live properties are computed from the filesystem and returned
by PROPFIND requests:
</p>

<ul>
<li><code>creationdate</code> - file creation time (ISO 8601 format)</li>
<li><code>displayname</code> - filename</li>
<li><code>getcontentlength</code> - file size in bytes (files only)</li>
<li><code>getcontenttype</code> - MIME type</li>
<li><code>getetag</code> - entity tag for conditional requests</li>
<li><code>getlastmodified</code> - last modification time (HTTP date format)</li>
<li><code>lockdiscovery</code> - active locks on the resource</li>
<li><code>resourcetype</code> - empty for files, <code>&lt;collection/&gt;</code>
for directories</li>
<li><code>supportedlock</code> - supported lock types (exclusive and shared
write locks)</li>
</ul>

<h4>Locking</h4>

<p>
WebDAV locks prevent conflicting modifications when multiple clients access
the same resource. Locks are:
</p>

<ul>
<li><b>In-memory</b> - locks are not persisted and are lost on server restart</li>
<li><b>Thread-safe</b> - lock management is safe for concurrent access</li>
<li><b>Time-limited</b> - locks have a configurable timeout (default: 1 hour,
maximum: 1 week)</li>
<li><b>Depth-aware</b> - locks can cover a resource only (depth 0), a
collection and its immediate children (depth 1), or an entire subtree
(depth infinity)</li>
</ul>

<p>
When a resource is locked, modifying operations (PUT, DELETE, MOVE, PROPPATCH)
require a valid lock token in the <code>If</code> or <code>Lock-Token</code>
header.
</p>

<h4>Example: PROPFIND Request</h4>

<pre>
PROPFIND /documents/ HTTP/1.1
Host: example.com
Depth: 1
Content-Type: application/xml

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;propfind xmlns="DAV:"&gt;
  &lt;prop&gt;
    &lt;displayname/&gt;
    &lt;getcontentlength/&gt;
    &lt;getlastmodified/&gt;
  &lt;/prop&gt;
&lt;/propfind&gt;
</pre>

<p>
Response (207 Multi-Status):
</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;D:multistatus xmlns:D="DAV:"&gt;
  &lt;D:response&gt;
    &lt;D:href&gt;/documents/&lt;/D:href&gt;
    &lt;D:propstat&gt;
      &lt;D:prop&gt;
        &lt;D:displayname&gt;documents&lt;/D:displayname&gt;
      &lt;/D:prop&gt;
      &lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;
    &lt;/D:propstat&gt;
  &lt;/D:response&gt;
  &lt;D:response&gt;
    &lt;D:href&gt;/documents/report.pdf&lt;/D:href&gt;
    &lt;D:propstat&gt;
      &lt;D:prop&gt;
        &lt;D:displayname&gt;report.pdf&lt;/D:displayname&gt;
        &lt;D:getcontentlength&gt;245678&lt;/D:getcontentlength&gt;
        &lt;D:getlastmodified&gt;Tue, 06 Jan 2026 12:00:00 GMT&lt;/D:getlastmodified&gt;
      &lt;/D:prop&gt;
      &lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;
    &lt;/D:propstat&gt;
  &lt;/D:response&gt;
&lt;/D:multistatus&gt;
</pre>

<h4>Example: LOCK Request</h4>

<pre>
LOCK /documents/report.pdf HTTP/1.1
Host: example.com
Timeout: Second-3600
Content-Type: application/xml

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;lockinfo xmlns="DAV:"&gt;
  &lt;lockscope&gt;&lt;exclusive/&gt;&lt;/lockscope&gt;
  &lt;locktype&gt;&lt;write/&gt;&lt;/locktype&gt;
  &lt;owner&gt;user@example.com&lt;/owner&gt;
&lt;/lockinfo&gt;
</pre>

<p>
Response includes the lock token:
</p>

<pre>
HTTP/1.1 200 OK
Lock-Token: &lt;opaquelocktoken:a1b2c3d4-e5f6-7890-abcd-ef1234567890&gt;
Content-Type: application/xml

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;D:prop xmlns:D="DAV:"&gt;
  &lt;D:lockdiscovery&gt;
    &lt;D:activelock&gt;
      &lt;D:locktype&gt;&lt;D:write/&gt;&lt;/D:locktype&gt;
      &lt;D:lockscope&gt;&lt;D:exclusive/&gt;&lt;/D:lockscope&gt;
      &lt;D:depth&gt;infinity&lt;/D:depth&gt;
      &lt;D:owner&gt;user@example.com&lt;/D:owner&gt;
      &lt;D:timeout&gt;Second-3600&lt;/D:timeout&gt;
      &lt;D:locktoken&gt;
        &lt;D:href&gt;opaquelocktoken:a1b2c3d4-e5f6-7890-abcd-ef1234567890&lt;/D:href&gt;
      &lt;/D:locktoken&gt;
    &lt;/D:activelock&gt;
  &lt;/D:lockdiscovery&gt;
&lt;/D:prop&gt;
</pre>

<hr/>

<p>
<a href="index.html">&larr; Back to Main Page</a> |
<a href="smtp.html">SMTP Server &amp; Client</a> |
<a href="imap.html">IMAP Server</a> |
<a href="pop3.html">POP3 Server</a> |
<a href="dns.html">DNS Server</a> |
<a href="telemetry.html">Telemetry</a>
</p>

<p class='server-info'>Gumdrop HTTP Server</p>

</body>
</html>

