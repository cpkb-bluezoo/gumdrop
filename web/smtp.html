<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "xhtml11.dtd">
<!--
  This file is part of gumdrop.

  gumdrop is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  gumdrop is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with gumdrop; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico"/>
<link rel="SHORTCUT ICON" href="favicon.ico"/>
<title>SMTP Server &amp; Client - Gumdrop</title>
</head>
<body>

<table summary='(layout)'>
<tr>
<td>
<img align="left" border="0" src="gumdrop.png" alt="(gumdrop)" />
</td>
<td valign='bottom'>
<h1 class='offset'>Gumdrop SMTP Server &amp; Client</h1>
</td>
</table>

<p><a href="index.html">&larr; Back to Main Page</a></p>

<p>
Gumdrop provides a complete SMTP implementation for both server and client
roles. The server supports RFC 5321 (SMTP) and RFC 6409 (Message Submission)
with full ESMTP extensions. Like all Gumdrop protocols, the SMTP implementation
is event-driven and non-blocking, achieving high performance with minimal
resource consumption.
</p>

<h3>Contents</h3>
<ul>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#handler">Connection Handler</a></li>
<li><a href="#pipeline">Processing Pipelines</a></li>
<li><a href="#email-auth">Email Authentication (SPF/DKIM/DMARC)</a></li>
<li><a href="#policy">Security Policies</a></li>
<li><a href="#authentication">SMTP Authentication</a></li>
<li><a href="#extensions">SMTP Extensions</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#client">SMTP Client</a></li>
<li><a href="#telemetry">Telemetry</a></li>
</ul>

<h3 id="architecture">Architecture</h3>

<p>
The SMTP server follows an "event-driven first" design philosophy. Rather than
allocating a thread per connection—a model that limits scalability to the
thousands—Gumdrop multiplexes all SMTP connections across a small pool of
worker threads using Java NIO selectors. This approach has been proven in
production since 2005 and enables a single server to handle tens of thousands
of concurrent connections.
</p>

<h4>Protocol State Machine</h4>

<p>
Each SMTP connection maintains a finite state machine that tracks its progress
through the protocol:
</p>

<ul>
<li><b>INITIAL</b> - connection established, awaiting HELO/EHLO</li>
<li><b>READY</b> - after successful greeting, ready for mail transaction</li>
<li><b>MAIL</b> - after MAIL FROM accepted</li>
<li><b>RCPT</b> - after one or more RCPT TO accepted</li>
<li><b>DATA</b> - receiving message content</li>
<li><b>QUIT</b> - connection closing</li>
</ul>

<p>
State transitions are validated strictly according to RFC 5321, with appropriate
error responses for out-of-sequence commands.
</p>

<h4>Non-Blocking DATA Processing</h4>

<p>
Message content during the DATA phase is processed as a stream without buffering
the entire message in memory. The protocol handles dot-stuffing, CRLF
normalisation, and termination detection (<code>CRLF.CRLF</code>) incrementally
as data arrives, allowing arbitrarily large messages to be processed efficiently.
</p>

<h3 id="handler">Connection Handler</h3>

<p>
Gumdrop separates protocol mechanics from business logic through the
<code>SMTPConnectionHandler</code> interface. The handler receives high-level
events about the SMTP session and makes policy decisions without dealing with
protocol syntax, response codes, or network I/O.
</p>

<h4>Handler Interface</h4>

<p>
Key handler methods:
</p>

<ul>
<li><code>connected(SMTPConnectionMetadata)</code> - connection established,
return false to reject early</li>
<li><code>hello(extended, clientDomain, HelloCallback)</code> - HELO/EHLO received</li>
<li><code>tlsStarted(SMTPConnectionMetadata)</code> - STARTTLS completed</li>
<li><code>authenticated(user, method)</code> - AUTH succeeded</li>
<li><code>mailFrom(senderAddress, MailFromCallback)</code> - sender evaluation</li>
<li><code>rcptTo(recipientAddress, RcptToCallback)</code> - recipient validation</li>
<li><code>startData(SMTPConnectionMetadata, DataStartCallback)</code> - DATA initiation</li>
<li><code>messageContent(ByteBuffer)</code> - streaming message data</li>
<li><code>endData(SMTPConnectionMetadata, DataEndCallback)</code> - message complete</li>
<li><code>reset()</code> - RSET command, clear transaction state</li>
<li><code>disconnected()</code> - connection closed</li>
</ul>

<h4>Asynchronous Callbacks</h4>

<p>
Policy methods use callbacks rather than return values, enabling asynchronous
evaluation. A handler can consult external services—databases, reputation
systems, content filters—without blocking the I/O thread. The callback must
be invoked on the connection's SelectorLoop thread:
</p>

<pre>
@Override
public void mailFrom(final String sender, final MailFromCallback callback) {
    final SelectorLoop loop = connection.getSelectorLoop();
    
    // Offload reputation check to worker thread
    executor.submit(new Runnable() {
        @Override
        public void run() {
            final SenderPolicyResult result = reputationService.checkSender(sender);
            
            // Re-dispatch callback to the connection's SelectorLoop thread
            loop.invokeLater(new Runnable() {
                @Override
                public void run() {
                    callback.mailFromReply(result);
                }
            });
        }
    });
}
</pre>

<p>
The SMTP connection automatically sends the appropriate protocol response when
the callback is invoked. Invoking the callback on the correct thread ensures
thread safety for all subsequent protocol operations.
</p>

<h4>Connection Metadata</h4>

<p>
Handlers receive rich context through <code>SMTPConnectionMetadata</code>:
</p>

<ul>
<li><b>Network information</b> - client IP, server address</li>
<li><b>Security context</b> - TLS status, cipher suite, protocol version</li>
<li><b>Client certificates</b> - X.509 certificates if provided</li>
<li><b>Authentication state</b> - authenticated user and mechanism</li>
<li><b>Connection timing</b> - establishment time, duration</li>
</ul>

<h4>Handler Factory</h4>

<p>
Handlers are created per-connection via a factory, ensuring thread safety and
state isolation:
</p>

<pre>
SMTPServer server = new SMTPServer();
server.setHandlerFactory(new SMTPConnectionHandlerFactory() {
    @Override
    public SMTPConnectionHandler createHandler() {
        return new MyMailHandler(config, dependencies);
    }
});
</pre>

<h3 id="pipeline">Processing Pipelines</h3>

<p>
Gumdrop provides a generic <code>SMTPPipeline</code> interface for processing
messages as they stream through the server. This enables pluggable processing
without modifying core SMTP code.
</p>

<h4>Pipeline Interface</h4>

<p>
The pipeline receives notifications at key SMTP stages:
</p>

<pre>
public interface SMTPPipeline {
    void mailFrom(EmailAddress sender);       // MAIL FROM received
    void rcptTo(EmailAddress recipient);      // RCPT TO received
    WritableByteChannel getMessageChannel();  // Called at DATA start
    void endData();                           // Message complete
    void reset();                             // Transaction reset
}
</pre>

<p>
When a pipeline is associated with an SMTPConnection:
</p>

<ul>
<li>Raw message bytes are written to the <code>WritableByteChannel</code> as they arrive</li>
<li>The channel is closed at end of DATA transfer</li>
<li><code>endData()</code> is called for final processing</li>
</ul>

<p>
This design supports various use cases:
</p>

<ul>
<li><b>Email authentication</b> - SPF, DKIM, DMARC validation</li>
<li><b>Content filtering</b> - spam detection, virus scanning</li>
<li><b>Archiving</b> - message journaling, compliance storage</li>
<li><b>Quota enforcement</b> - per-user or per-domain limits</li>
</ul>

<h4>WritableByteChannel Pattern</h4>

<p>
The <code>WritableByteChannel</code> is a standard Java interface that clearly
expresses streaming semantics:
</p>

<ul>
<li><code>write(ByteBuffer)</code> - receive message bytes</li>
<li><code>close()</code> - signal end of stream</li>
<li><code>isOpen()</code> - check channel state</li>
</ul>

<p>
This allows pipelines to process arbitrarily large messages without buffering
the entire content in memory.
</p>

<h3 id="email-auth">Email Authentication (SPF/DKIM/DMARC)</h3>

<p>
The <code>org.bluezoo.gumdrop.smtp.auth</code> package provides
<code>AuthPipeline</code>, an implementation of <code>SMTPPipeline</code>
that performs SPF, DKIM, and DMARC validation.
</p>

<h4>How It Works</h4>

<p>
When associated with a connection, AuthPipeline automatically:
</p>

<ol>
<li><b>SPF check</b> - runs asynchronously when MAIL FROM is received,
using DNS TXT record lookup to validate sender authorization</li>
<li><b>Header parsing</b> - as message bytes stream in, headers are parsed
to collect DKIM-Signature and extract the From domain</li>
<li><b>Body hashing</b> - raw body bytes (after CRLFCRLF) are hashed for
DKIM verification</li>
<li><b>DKIM verification</b> - at end-of-data, the signature is verified
against the DNS public key</li>
<li><b>DMARC evaluation</b> - after DKIM, DMARC policy is checked with
SPF/DKIM alignment</li>
</ol>

<h4>Pipeline Flow Diagram</h4>

<p>
The following diagram shows how data flows through the AuthPipeline at each
stage, including the optional user MessageHandler for receiving teed content:
</p>

<figure style="margin: 2em 0; text-align: center;">
<object type="image/svg+xml" data="auth-pipeline.svg" style="max-width: 100%; height: auto;">
  <img src="auth-pipeline.svg" alt="AuthPipeline Message Flow Diagram"/>
</object>
<figcaption style="margin-top: 0.5em; font-style: italic; color: #666;">
AuthPipeline processes messages in three stages: MAIL FROM (SPF), DATA streaming
(header parsing + body hashing), and End of DATA (DKIM + DMARC verification).
</figcaption>
</figure>

<h4>Callback-Based Results</h4>

<p>
Configure the pipeline with callbacks for the checks you care about:
</p>

<pre>
AuthPipeline.Builder builder = new AuthPipeline.Builder(resolver, clientIP, heloHost);

// SPF callback - invoked during MAIL FROM processing
builder.onSPF(new SPFCallback() {
    @Override
    public void onResult(SPFResult result, String explanation) {
        if (result == SPFResult.FAIL) {
            mailFromCallback.mailFromReply(SenderPolicyResult.REJECT);
        } else {
            mailFromCallback.mailFromReply(SenderPolicyResult.ACCEPT);
        }
    }
});

// DKIM callback - invoked at end-of-data
builder.onDKIM(new DKIMCallback() {
    @Override
    public void onResult(DKIMResult result, String domain, String selector) {
        // Store result for logging
    }
});

// DMARC callback - invoked after DKIM
builder.onDMARC(new DMARCCallback() {
    @Override
    public void onResult(DMARCResult result, DMARCPolicy policy, String domain) {
        // Can now respond to DATA command
        if (result == DMARCResult.FAIL &amp;&amp; policy == DMARCPolicy.REJECT) {
            dataEndCallback.reply(DataEndReply.REJECT);
        } else {
            dataEndCallback.reply(DataEndReply.ACCEPT);
        }
    }
});

// Or use combined result callback
builder.onComplete(new AuthResultCallback() {
    @Override
    public void onResult(AuthResult result) {
        if (result.shouldReject()) {
            dataEndCallback.reply(DataEndReply.REJECT);
        } else {
            dataEndCallback.reply(DataEndReply.ACCEPT);
        }
    }
});

// Associate with connection
connection.setPipeline(builder.build());
</pre>

<h4>Message Handler Integration</h4>

<p>
To process message content while authentication runs in parallel, register
a <code>MessageHandler</code>:
</p>

<pre>
builder.messageHandler(new MessageHandler() {
    @Override
    public void header(String name, String value) {
        // Receive parsed headers
    }
    
    @Override
    public void addressHeader(String name, List&lt;EmailAddress&gt; addresses) {
        // Receive parsed address headers (From, To, Cc, etc.)
    }
    
    @Override
    public void bodyContent(ByteBuffer data) {
        // Receive decoded body content
    }
});
</pre>

<p>
The handler receives events from a composite handler that also feeds the
authentication checks. This avoids parsing the message twice while allowing
your application to process content.
</p>

<h4>AuthResult and Verdict</h4>

<p>
<code>AuthResult</code> contains individual SPF, DKIM, and DMARC results plus
a combined <code>AuthVerdict</code>:
</p>

<ul>
<li><b>PASS</b> - authentication passed, deliver normally</li>
<li><b>REJECT</b> - DMARC policy is reject, refuse message</li>
<li><b>QUARANTINE</b> - DMARC policy is quarantine, deliver to spam folder</li>
<li><b>NONE</b> - no authentication info or DMARC policy is none</li>
</ul>

<p>
Convenience methods: <code>result.passed()</code>, <code>result.shouldReject()</code>,
<code>result.shouldQuarantine()</code>.
</p>

<h3 id="policy">Security Policies</h3>

<p>
Gumdrop provides comprehensive policy evaluation through typed result enums
that abstract SMTP response codes.
</p>

<h4>Sender Policy Results</h4>

<p>
<code>SenderPolicyResult</code> for MAIL FROM evaluation:
</p>

<ul>
<li><b>ACCEPT</b> - sender is valid (250)</li>
<li><b>TEMP_REJECT_GREYLIST</b> - greylisting delay (450)</li>
<li><b>TEMP_REJECT_RATE_LIMIT</b> - rate limit exceeded (450)</li>
<li><b>REJECT_BLOCKED_DOMAIN</b> - domain on blocklist (550)</li>
<li><b>REJECT_INVALID_DOMAIN</b> - domain does not exist (550)</li>
<li><b>REJECT_POLICY_VIOLATION</b> - business rule violation (553)</li>
<li><b>REJECT_SPAM_REPUTATION</b> - known spam source (554)</li>
<li><b>REJECT_SYNTAX_ERROR</b> - malformed address (501)</li>
<li><b>REJECT_RELAY_DENIED</b> - relaying not permitted (551)</li>
<li><b>REJECT_STORAGE_FULL</b> - system storage unavailable (452)</li>
</ul>

<h4>Recipient Policy Results</h4>

<p>
<code>RecipientPolicyResult</code> for RCPT TO evaluation:
</p>

<ul>
<li><b>ACCEPT</b> - recipient is valid (250)</li>
<li><b>ACCEPT_FORWARD</b> - will forward to another host (251)</li>
<li><b>TEMP_REJECT_UNAVAILABLE</b> - mailbox temporarily unavailable (450)</li>
<li><b>TEMP_REJECT_SYSTEM_ERROR</b> - local processing error (451)</li>
<li><b>TEMP_REJECT_STORAGE_FULL</b> - insufficient storage (452)</li>
<li><b>REJECT_MAILBOX_UNAVAILABLE</b> - mailbox does not exist (550)</li>
<li><b>REJECT_USER_NOT_LOCAL</b> - user not handled here (551)</li>
<li><b>REJECT_QUOTA_EXCEEDED</b> - user quota full (552)</li>
<li><b>REJECT_INVALID_MAILBOX</b> - mailbox name not allowed (553)</li>
<li><b>REJECT_TRANSACTION_FAILED</b> - transaction failure (554)</li>
<li><b>REJECT_SYNTAX_ERROR</b> - malformed address (501)</li>
<li><b>REJECT_RELAY_DENIED</b> - relaying not permitted (551)</li>
<li><b>REJECT_POLICY_VIOLATION</b> - policy violation (553)</li>
</ul>

<h4>Connection-Level Filtering</h4>

<p>
The SMTP server performs connection-level filtering before any protocol
exchange:
</p>

<ul>
<li><b>CIDR allow/block lists</b> - fast network matching with pre-parsed
CIDR blocks supporting both IPv4 and IPv6</li>
<li><b>Concurrent connection limits</b> - per-IP connection cap prevents
resource exhaustion</li>
<li><b>Rate limiting</b> - sliding window rate limits per IP address</li>
</ul>

<p>
Blocked connections are rejected immediately without consuming handler resources.
</p>

<h3 id="authentication">Authentication</h3>

<p>
Gumdrop supports the full range of SMTP AUTH mechanisms:
</p>

<ul>
<li><b>PLAIN</b> - simple username/password (RFC 4616)</li>
<li><b>LOGIN</b> - legacy base64-encoded credentials</li>
<li><b>CRAM-MD5</b> - challenge-response (RFC 2195)</li>
<li><b>DIGEST-MD5</b> - digest authentication (RFC 2831)</li>
<li><b>SCRAM-SHA-256</b> - salted challenge-response (RFC 7677)</li>
<li><b>OAUTHBEARER</b> - OAuth 2.0 bearer tokens (RFC 7628)</li>
<li><b>GSSAPI</b> - Kerberos authentication (RFC 4752)</li>
<li><b>EXTERNAL</b> - TLS client certificate (RFC 4422)</li>
</ul>

<p>
Authentication integrates with Gumdrop's centralised
<code>org.bluezoo.gumdrop.auth.Realm</code> facility for unified credential
management across all servers.
</p>

<h4>STARTTLS</h4>

<p>
The server supports opportunistic TLS upgrade via STARTTLS (RFC 3207). When
a keystore is configured, STARTTLS is advertised in EHLO responses. After
successful TLS negotiation, the SMTP session resets and the client must
re-issue EHLO.
</p>

<h3 id="extensions">SMTP Extensions</h3>

<p>
Beyond the standard ESMTP capabilities, Gumdrop supports several extensions
for enhanced functionality:
</p>

<h4>CHUNKING (RFC 3030)</h4>

<p>
The BDAT command provides an alternative to DATA for transmitting message
content. Instead of using dot-stuffing and <code>CRLF.CRLF</code> termination,
BDAT specifies an exact byte count:
</p>

<pre>
BDAT 1000
&lt;exactly 1000 bytes of content&gt;
BDAT 500 LAST
&lt;exactly 500 bytes of content&gt;
</pre>

<p>
Benefits of CHUNKING:
</p>

<ul>
<li><b>Binary safety</b> - no dot-stuffing means binary content passes through
unmodified</li>
<li><b>Predictable transfer</b> - sender and receiver know exact byte counts</li>
<li><b>Efficient processing</b> - no scanning for termination sequences</li>
</ul>

<p>
The handler receives message content through the same <code>messageContent()</code>
method regardless of whether DATA or BDAT was used—the protocol difference is
handled entirely by SMTPConnection.
</p>

<h4>BINARYMIME (RFC 3030)</h4>

<p>
BINARYMIME extends CHUNKING to allow raw binary content without any encoding.
The sender declares binary content via the BODY parameter:
</p>

<pre>
MAIL FROM:&lt;sender@example.com&gt; BODY=BINARYMIME
</pre>

<p>
When BODY=BINARYMIME is declared, the message MUST be transmitted using BDAT
because the DATA command's dot-stuffing could corrupt binary data. The server
enforces this—if a client attempts to use DATA after declaring BINARYMIME,
the server rejects with a 503 error.
</p>

<p>
The BODY parameter supports three values:
</p>

<ul>
<li><b>7BIT</b> - traditional 7-bit ASCII content (default)</li>
<li><b>8BITMIME</b> - 8-bit MIME content (RFC 6152)</li>
<li><b>BINARYMIME</b> - raw binary content (requires BDAT)</li>
</ul>

<p>
The handler does not need to know about BODY type—the difference is entirely
a transport concern handled by SMTPConnection.
</p>

<h4>SMTPUTF8 (RFC 6531)</h4>

<p>
Internationalized Email allows UTF-8 characters in email addresses, including
the local-part, domain, and display names. When a client includes the SMTPUTF8
parameter with MAIL FROM, the server accepts addresses like:
</p>

<pre>
MAIL FROM:&lt;用户@例え.jp&gt; SMTPUTF8
RCPT TO:&lt;почта@пример.рф&gt;
</pre>

<p>
The <code>smtputf8</code> flag is passed to the handler via the
<code>mailFrom()</code> callback, allowing the handler to configure message
parsing appropriately. The <code>MessageParser</code> class provides
<code>setSmtputf8(boolean)</code> for this purpose.
</p>

<h4>XCLIENT (Postfix Extension)</h4>

<p>
XCLIENT allows authorized mail proxies and content filters to pass original
client connection information to the MTA. This is essential when mail passes
through intermediary systems that need to preserve the original client's
identity for logging, policy evaluation, and authentication checks.
</p>

<p>
Supported XCLIENT attributes:
</p>

<ul>
<li><b>NAME</b> - original client hostname</li>
<li><b>ADDR</b> - original client IP address</li>
<li><b>PORT</b> - original client port</li>
<li><b>PROTO</b> - protocol (SMTP or ESMTP)</li>
<li><b>HELO</b> - original HELO/EHLO name</li>
<li><b>LOGIN</b> - authenticated username</li>
<li><b>DESTADDR</b> - original destination IP</li>
<li><b>DESTPORT</b> - original destination port</li>
</ul>

<p>
After XCLIENT, the session resets to the greeting state and the client must
re-issue EHLO. The overridden values are reflected in
<code>SMTPConnectionMetadata</code> for policy decisions.
</p>

<p>
XCLIENT is only available to authorized clients. The handler controls
authorization through the <code>isXclientAuthorized(InetAddress)</code> method,
which returns <code>false</code> by default. Enable it only for trusted hosts:
</p>

<pre>
&#64;Override
public boolean isXclientAuthorized(InetAddress clientAddress) {
    // Allow localhost and internal mail gateways
    return clientAddress.isLoopbackAddress() ||
           clientAddress.getHostAddress().startsWith("10.0.1.");
}
</pre>

<h4>DSN - Delivery Status Notifications (RFC 3461)</h4>

<p>
DSN allows senders to request notification of message delivery status.
The sender can specify when to receive notifications and how much of the
original message to include in the notification.
</p>

<p>
MAIL FROM parameters:
</p>

<ul>
<li><b>RET=FULL|HDRS</b> - return full message or just headers in DSN</li>
<li><b>ENVID=&lt;id&gt;</b> - envelope identifier for correlation</li>
</ul>

<p>
RCPT TO parameters:
</p>

<ul>
<li><b>NOTIFY=NEVER|SUCCESS|FAILURE|DELAY</b> - when to send DSN (comma-separated)</li>
<li><b>ORCPT=&lt;type&gt;;&lt;addr&gt;</b> - original recipient address</li>
</ul>

<p>
Example transaction with DSN:
</p>

<pre>
MAIL FROM:&lt;sender@example.com&gt; RET=HDRS ENVID=msg12345
RCPT TO:&lt;user@example.org&gt; NOTIFY=SUCCESS,FAILURE ORCPT=rfc822;user@example.org
</pre>

<p>
The DSN parameters are accessible through <code>SMTPConnectionMetadata</code>:
</p>

<ul>
<li><code>getDSNEnvelopeParameters()</code> - returns RET and ENVID</li>
<li><code>getDSNRecipientParameters(EmailAddress)</code> - returns NOTIFY and ORCPT for a recipient</li>
</ul>

<p>
The MTA is responsible for generating actual DSN messages based on these
parameters when delivery succeeds, fails, or is delayed.
</p>

<h4>LIMITS (RFC 9422)</h4>

<p>
The LIMITS extension allows the server to advertise operational limits upfront
in the EHLO response. This helps clients avoid sending commands that would be
rejected due to limits.
</p>

<p>
Advertised limits:
</p>

<ul>
<li><b>RCPTMAX</b> - maximum recipients per transaction (default: 100)</li>
<li><b>MAILMAX</b> - maximum mail transactions per session (default: unlimited)</li>
</ul>

<p>
Example EHLO response with LIMITS:
</p>

<pre>
250-LIMITS RCPTMAX=100 MAILMAX=50
</pre>

<p>
Configuration via <code>SMTPServer</code>:
</p>

<ul>
<li><code>setMaxRecipients(int)</code> - set RCPTMAX limit</li>
<li><code>setMaxTransactionsPerSession(int)</code> - set MAILMAX limit (0 = unlimited)</li>
</ul>

<p>
When limits are exceeded:
</p>

<ul>
<li>RCPTMAX: Returns 452 (too many recipients) and rejects additional RCPT TO commands</li>
<li>MAILMAX: Returns 421 (too many transactions) and closes the connection</li>
</ul>

<h4>Delivery Requirements</h4>

<p>
Several SMTP extensions allow senders to specify requirements for how messages
should be delivered. These are collected in the <code>DeliveryRequirements</code>
interface, which is passed to the handler's <code>mailFrom()</code> callback:
</p>

<h5>REQUIRETLS (RFC 8689)</h5>

<p>
Indicates that the message must only be transmitted over TLS-protected connections.
If TLS cannot be guaranteed for any hop, the message should bounce.
</p>

<pre>
MAIL FROM:&lt;sender@example.com&gt; REQUIRETLS
</pre>

<p>
The server automatically supports REQUIRETLS when TLS is available. If specified
on a non-TLS connection, the server returns <code>530 5.7.10 REQUIRETLS requires
TLS connection</code>.
</p>

<h5>MT-PRIORITY (RFC 6710)</h5>

<p>
Specifies message transfer priority from -9 (lowest) to +9 (highest), with 0
being normal priority. MTAs may use this to prioritize queue processing.
</p>

<pre>
MAIL FROM:&lt;sender@example.com&gt; MT-PRIORITY=5
</pre>

<h5>FUTURERELEASE (RFC 4865)</h5>

<p>
Requests that the message be held for later delivery. Two forms are supported:
</p>

<pre>
MAIL FROM:&lt;sender@example.com&gt; HOLDFOR=3600
MAIL FROM:&lt;sender@example.com&gt; HOLDUNTIL=2025-12-25T00:00:00Z
</pre>

<p>
<code>HOLDFOR</code> specifies seconds from now; <code>HOLDUNTIL</code> specifies
an ISO 8601 timestamp.
</p>

<h5>DELIVERBY (RFC 2852)</h5>

<p>
Specifies a delivery deadline. If the message cannot be delivered in time,
it should be returned (R) or a delay DSN sent (N):
</p>

<pre>
MAIL FROM:&lt;sender@example.com&gt; BY=86400;R
MAIL FROM:&lt;sender@example.com&gt; BY=86400;N
</pre>

<h5>Handler Usage</h5>

<p>
All delivery requirements are available via <code>DeliveryRequirements</code>:
</p>

<pre>
&#64;Override
public void mailFrom(EmailAddress sender, boolean smtputf8,
                     DeliveryRequirements delivery, MailFromCallback callback) {
    if (delivery.isRequireTls()) {
        // Must relay over TLS only
    }
    if (delivery.hasPriority()) {
        int priority = delivery.getPriority(); // -9 to +9
    }
    if (delivery.isFutureRelease()) {
        Instant releaseTime = delivery.getReleaseTime();
    }
    if (delivery.hasDeliverByDeadline()) {
        Instant deadline = delivery.getDeliverByDeadline();
        boolean returnOnFail = delivery.isDeliverByReturn();
    }
    if (delivery.hasDsnParameters()) {
        DSNReturn ret = delivery.getDsnReturn();
        String envid = delivery.getDsnEnvelopeId();
    }
    callback.mailFromReply(SenderPolicyResult.ACCEPT);
}
</pre>

<h3 id="configuration">Configuration</h3>

<h4>SMTPService Properties</h4>

<p>
SMTP services (<code>org.bluezoo.gumdrop.smtp.SMTPService</code> subclasses) support:
</p>

<ul>
<li><code>realm</code> &ndash; reference to a Realm for authentication</li>
<li><code>mailbox-factory</code> &ndash; reference to a MailboxFactory (for local delivery)</li>
<li><code>max-message-size</code> &ndash; maximum message size in bytes (default: ~35MB)</li>
<li><code>max-recipients</code> &ndash; maximum recipients per transaction (default: 100)</li>
<li><code>max-transactions-per-session</code> &ndash; maximum MAIL FROM commands per session (default: 0/unlimited)</li>
<li><code>auth-required</code> &ndash; require authentication (for submission port)</li>
</ul>

<h4>SMTPListener Properties</h4>

<p>
Each <code>&lt;listener&gt;</code> element within the service configures a listener:
</p>

<ul>
<li><code>port</code> &ndash; listening port (default: 25, or 465 for secure)</li>
<li><code>secure</code> &ndash; enable implicit TLS (SMTPS)</li>
<li><code>keystore-file</code> &ndash; keystore for TLS/STARTTLS</li>
<li><code>keystore-pass</code> &ndash; keystore password</li>
<li><code>max-connections-per-ip</code> &ndash; concurrent connection limit per IP (default: 10)</li>
<li><code>allowed-networks</code> &ndash; CIDR networks to allow (e.g., "192.168.0.0/16")</li>
<li><code>blocked-networks</code> &ndash; CIDR networks to block</li>
</ul>

<h4>Example Configuration</h4>

<pre>
&lt;!-- Authentication realm --&gt;
&lt;realm id="mailRealm" class="org.bluezoo.gumdrop.auth.BasicRealm"&gt;
    &lt;property name="href"&gt;mail-users.xml&lt;/property&gt;
&lt;/realm&gt;

&lt;!-- SMTP service with MX and submission listeners --&gt;
&lt;service class="com.example.MyMailService"&gt;
    &lt;property name="realm" ref="#mailRealm"/&gt;
    &lt;property name="max-message-size"&gt;52428800&lt;/property&gt;

    &lt;!-- MX listener (port 25) --&gt;
    &lt;listener class="org.bluezoo.gumdrop.smtp.SMTPListener"
            name="mx" port="25"
            keystore-file="keystore.p12" keystore-pass="secret"
            max-connections-per-ip="20"
            blocked-networks="10.0.0.0/8"/&gt;

    &lt;!-- Submission listener (port 587, auth required) --&gt;
    &lt;listener class="org.bluezoo.gumdrop.smtp.SMTPListener"
            name="submission" port="587"
            keystore-file="keystore.p12" keystore-pass="secret"
            auth-required="true"/&gt;

    &lt;!-- UNIX domain socket for local delivery agents --&gt;
    &lt;listener class="org.bluezoo.gumdrop.smtp.SMTPListener"
            name="local" path="/var/run/smtp.sock"/&gt;
&lt;/service&gt;
</pre>

<h3 id="client">SMTP Client</h3>

<p>
Gumdrop includes a non-blocking SMTP client that shares the same event-driven
architecture as the server. The client is designed for integration into MTA
forward delivery components and service-to-service communication.
</p>

<h4>SelectorLoop Affinity</h4>

<p>
When an SMTP client connection is initiated from within a Gumdrop server
context—such as a mail relay or gateway—it can be assigned to the same
SelectorLoop as the originating server connection. This provides the same
benefits described for the <a href="http.html#client">HTTP client</a>:
</p>

<ul>
<li><b>Unified I/O model</b> - client and server connections share the same
non-blocking infrastructure, avoiding thread context switches and complex
race conditions when forwarding mail from an inbound connection</li>
<li><b>Connection affinity</b> - outbound delivery connections remain bound
to their worker thread, simplifying state management for pipelined operations</li>
<li><b>Resource efficiency</b> - forward delivery multiplexes with inbound I/O
on existing workers rather than requiring additional thread pools</li>
<li><b>TLS integration</b> - STARTTLS negotiation on outbound connections is
handled inline on the assigned worker</li>
</ul>

<p>
This makes the SMTP client particularly well-suited for MTA implementations
where inbound mail must be relayed to downstream servers. The relay operation
executes entirely within the I/O worker without blocking.
</p>

<h4>Client Features</h4>

<ul>
<li><b>Asynchronous operation</b> - integrates with Gumdrop's SelectorLoop</li>
<li><b>ESMTP support</b> - EHLO with extension discovery</li>
<li><b>STARTTLS</b> - opportunistic TLS upgrade</li>
<li><b>Streaming DATA</b> - dot-stuffing handled automatically without buffering</li>
<li><b>Pipelining</b> - multiple commands in flight (when server supports)</li>
</ul>

<h4>Client Handler Interface</h4>

<p>
The client is driven by an <code>SMTPClientHandler</code> that receives
protocol events:
</p>

<pre>
SMTPClient client = new SMTPClient("mail.example.com", 25);
client.connect(new SMTPClientHandler() {
    @Override
    public void onConnected() {
        // TCP connection established, awaiting greeting
    }
    
    @Override
    public void onGreeting(SMTPResponse greeting, SMTPClientProtocolHandler handler) {
        handler.ehlo("myhost.example.com");
    }
    
    @Override
    public void onReply(SMTPResponse response, SMTPClientProtocolHandler handler) {
        // Handle command responses
        if (response.isSuccess()) {
            // Proceed with next command
        }
    }
    
    @Override
    public void onTLSStarted() {
        // TLS negotiation complete, re-issue EHLO
    }
    
    @Override
    public void onError(SMTPException error) {
        // Handle protocol or connection errors
    }
    
    @Override
    public void onDisconnected() {
        // Connection closed
    }
});
</pre>

<h4>Message Transmission</h4>

<p>
Message content is sent as a stream with automatic dot-stuffing:
</p>

<pre>
// After MAIL FROM and RCPT TO accepted, DATA command sent
conn.data();  // Sends DATA command

// In onReply(), when 354 received:
ByteBuffer content = getMessageContent();
conn.messageContent(content);  // Dot-stuffed automatically
conn.endData();  // Sends CRLF.CRLF terminator
</pre>

<h3 id="telemetry">Telemetry</h3>

<p>
The SMTP server integrates with Gumdrop's OpenTelemetry implementation for
distributed tracing. When telemetry is enabled, the server creates traces
and spans that provide visibility into mail flow.
</p>

<h4>Trace Structure</h4>

<ul>
<li><b>Connection trace</b> - root span covering the entire TCP connection
with attributes for client IP, transport protocol, and connection duration</li>
<li><b>Session spans</b> - child spans for each SMTP session (transaction),
where a session runs from MAIL FROM to message acceptance or RSET/QUIT</li>
</ul>

<p>
Session spans capture:
</p>

<ul>
<li><code>smtp.session_number</code> - session index within connection</li>
<li><code>smtp.client_hostname</code> - HELO/EHLO hostname</li>
<li><code>smtp.esmtp_mode</code> - EHLO vs HELO</li>
<li><code>smtp.mail_from</code> - sender address</li>
<li><code>smtp.auth.mechanism</code> - authentication method if used</li>
<li><code>smtp.auth.user</code> - authenticated username</li>
<li>Events for RCPT TO recipients, STARTTLS, message acceptance</li>
</ul>

<p>
Telemetry data is exported to an OpenTelemetry Collector using the OTLP/HTTP
protocol. The exporter uses Gumdrop's native HTTP client with SelectorLoop
affinity for efficient, non-blocking delivery.
</p>

<hr/>

<p>
<a href="index.html">&larr; Back to Main Page</a> |
<a href="http.html">HTTP Server &amp; Client</a> |
<a href="imap.html">IMAP Server</a> |
<a href="pop3.html">POP3 Server</a> |
<a href="dns.html">DNS Server</a> |
<a href="telemetry.html">Telemetry</a>
</p>

<p class='server-info'>Gumdrop SMTP Server</p>

</body>
</html>

