<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "xhtml11.dtd">
<!--
  This file is part of gumdrop.

  gumdrop is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  gumdrop is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with gumdrop; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico"/>
<link rel="SHORTCUT ICON" href="favicon.ico"/>
<title>gumdrop</title>
</head>
<body>

<header>
<img src="gumdrop.png" alt="Gumdrop" />
<h1>gumdrop</h1>
</header>

<p>
Congratulations, you've installed Gumdrop!
</p>

<p>
Gumdrop is a multipurpose Java server framework using asynchronous,
non-blocking, event-driven I/O. It provides a generic, extensible server
architecture with transparent TLS support, and includes implementations for
HTTP, SMTP, IMAP, POP3, FTP, and DNS protocols.
</p>

<h3>Documentation</h3>

<ul>
<li><a href="servlet.html"><strong>Servlet Container</strong></a> - features,
architecture, configuration, clustering, and deployment</li>
<li><a href="http.html"><strong>HTTP Server &amp; Client</strong></a> - HTTP/3,
HTTP/2, HTTP/1.x, HPACK, and QPACK</li>
<li><a href="webdav.html"><strong>File Server &amp; WebDAV</strong></a> - static
file serving, WebDAV distributed authoring, and locking</li>
<li><a href="websocket.html"><strong>WebSocket Service &amp; Client</strong></a> -
standalone WebSocket services, client connections, and servlet integration</li>
<li><a href="smtp.html"><strong>SMTP Server &amp; Client</strong></a> - mail
submission, relay, security policies, and authentication</li>
<li><a href="imap.html"><strong>IMAP Server</strong></a> - IMAP4rev2 with IDLE,
NAMESPACE, MOVE, QUOTA, and SASL authentication</li>
<li><a href="pop3.html"><strong>POP3 Server</strong></a> - POP3 with APOP,
SASL authentication, and UTF-8 support</li>
<li><a href="ftp.html"><strong>FTP Server</strong></a> - FTP with TLS,
role-based access control, and quota management</li>
<li><a href="dns.html"><strong>DNS Server</strong></a> - DNS proxy with caching,
custom resolution, and DTLS support</li>
<li><a href="mailbox.html"><strong>Mailbox API</strong></a> - storage abstraction
for IMAP, POP3, and SMTP with mbox and Maildir implementations</li>
<li><a href="telemetry.html"><strong>Telemetry</strong></a> - OpenTelemetry
distributed tracing and metrics with OTLP export</li>
<li><a href="security.html"><strong>Security</strong></a> - IAM, rate limiting,
TLS, and authentication across all protocols</li>
<li><a href="redis.html"><strong>Redis Client</strong></a> - asynchronous Redis
client with SelectorLoop affinity for server integration</li>
<li><a href="configuration.html"><strong>Configuration</strong></a> -
dependency injection framework, property syntax, and example configurations</li>
</ul>

<h3>Architecture</h3>

<p>
Gumdrop uses an event-driven, non-blocking I/O architecture first developed in
2005 based on the then-new Java NIO Selector API. This architecture was the
original motivator for the project at a time when mainstream enterprise servlet
containers still used blocking <code>java.net.Socket</code> implementations
that directly tied the number of incoming connections to JVM threads,
preventing scalability.
</p>

<p style="text-align:center">
<img src="architecture.svg" alt="Gumdrop Architecture Diagram" style="max-width:100%"/>
</p>

<h4>Asynchronous vs Synchronous</h4>

<p>
Traditional synchronous servers allocate one thread per connection. A thread
blocks on socket read, processes the request, blocks on socket write, and
repeats. This model is simple but has fundamental scalability limitations:
</p>

<ul>
<li><b>Thread overhead</b> - each thread consumes stack memory (typically 1MB)
and kernel resources; 10,000 connections require 10,000 threads</li>
<li><b>Context switching</b> - the OS scheduler must switch between thousands
of threads, consuming CPU cycles</li>
<li><b>Blocking I/O waste</b> - threads spend most time waiting for network I/O,
not doing useful work</li>
<li><b>Thundering herd</b> - bursts of activity can exhaust thread pools</li>
</ul>

<p>
Gumdrop's asynchronous architecture inverts this model. A small, fixed pool of
worker threads (default: 2× CPU cores) handles I/O for all connections:
</p>

<ul>
<li><b>Minimal threads</b> - 10,000 connections can be served by 16 threads</li>
<li><b>No blocking</b> - workers never block; when data isn't available, they
move to the next ready connection</li>
<li><b>Efficient multiplexing</b> - the OS <code>Selector</code> notifies
workers when connections are ready</li>
<li><b>Predictable resource usage</b> - memory and CPU scale with traffic, not
connection count</li>
</ul>

<h4>Event-Driven Model</h4>

<p>
The event-driven model is particularly suited to modern distributed enterprise
systems where services communicate over HTTP, message queues, and databases.
These systems are inherently I/O-bound: services spend most time waiting for
network responses. An event-driven server maximises throughput by never
waiting—when one connection is idle, the worker immediately serves another.
</p>

<h4>SelectorLoop Architecture</h4>

<p>
A single <code>AcceptSelectorLoop</code> thread handles accepting new
connections on all server ports. When a connection is accepted, the resulting
endpoint is assigned to one of a pool of worker <code>SelectorLoop</code>
threads using round-robin distribution. Each endpoint is bound to a single
worker for its entire lifetime, eliminating race conditions and simplifying
state management.
</p>

<p style="text-align:center">
<img src="classes.svg" alt="Gumdrop Class Hierarchy" style="max-width:100%"/>
</p>

<h3>Servers</h3>

<p>
The <code>Listener</code> abstract class represents a protocol server
listening on a port. It is transport-agnostic: the <code>createTransportFactory()</code>
hook selects the transport (TCP by default, but UDP or QUIC can be substituted).
When the <code>AcceptSelectorLoop</code> accepts an incoming connection, it
delegates to the server's <code>createHandler()</code> factory method to obtain
a protocol-specific <code>ProtocolHandler</code>.
</p>

<p>
Server implementations define:
</p>

<ul>
<li><code>getPort()</code> - the port to listen on</li>
<li><code>createHandler()</code> - factory method returning an
<code>ProtocolHandler</code> for the accepted endpoint</li>
<li><code>createTransportFactory()</code> - selects the transport layer
(defaults to <code>TCPTransportFactory</code>)</li>
</ul>

<p>
TLS configuration (keystore, password, format, client authentication, ALPN) is
set as properties on <code>Listener</code> and delegated to the
<code>TransportFactory</code>. CIDR filtering and rate limiting are also
configured via server properties.
</p>

<h3>Clients</h3>

<p>
<code>ClientEndpoint</code> launches outbound connections using the same
event-driven infrastructure as servers. A <code>ClientHandler</code>
receives lifecycle callbacks (connected, received data, security established,
disconnected). <code>ClientEndpointPool</code> manages pooled outbound
endpoints with <code>SelectorLoop</code> affinity.
</p>

<p>
When a client endpoint is created within a server context (e.g., an SMTP relay
forwarding mail), it can be assigned to the same <code>SelectorLoop</code> as
the originating server endpoint. This <i>SelectorLoop affinity</i> provides:
</p>

<ul>
<li><b>Unified I/O</b> - server and client I/O multiplexed on the same thread</li>
<li><b>No context switching</b> - data flows without thread handoffs</li>
<li><b>Simplified state</b> - no synchronisation needed between endpoints</li>
<li><b>Efficient relay</b> - proxies and gateways operate entirely within
their worker thread</li>
</ul>

<h3>Endpoints and Handlers</h3>

<p>
The architecture decouples transport I/O from protocol logic.
<code>Endpoint</code> is the transport-agnostic I/O interface, providing:
</p>

<ul>
<li><code>send(ByteBuffer)</code> - queues data for transmission</li>
<li><code>startTLS()</code> - initiates STARTTLS upgrade</li>
<li><code>close()</code> - closes the endpoint</li>
<li><code>isOpen()</code> - tests whether the endpoint is active</li>
<li><code>getRemoteAddress()</code>, <code>getLocalAddress()</code> - peer
addresses</li>
</ul>

<p>
<code>ProtocolHandler</code> is the callback interface for protocol logic:
</p>

<ul>
<li><code>connected(Endpoint)</code> - called when the endpoint is ready</li>
<li><code>receive(Endpoint, ByteBuffer)</code> - called when data arrives</li>
<li><code>securityEstablished(SecurityInfo)</code> - called after TLS
handshake</li>
<li><code>disconnected(Endpoint)</code> - called on close</li>
</ul>

<p>
Protocol implementations (HTTP, SMTP, IMAP, etc.) implement
<code>ProtocolHandler</code> rather than extending a base class.
<code>LineParser</code> replaces the former <code>LineBasedConnection</code>
for line-oriented protocols, using composition instead of inheritance. The
framework handles read/write buffering, TLS encryption/decryption, and
endpoint lifecycle.
</p>

<h3>Staged Handler Pattern</h3>

<p>
Stateful protocols such as SMTP, IMAP, and POP3 present a particular challenge:
tracking the current protocol state and understanding what operations are valid
at any given moment. This difficulty is compounded by event-driven architectures
like Gumdrop, where the complexity of asynchronous callbacks can be bewildering.
</p>

<p>
Gumdrop addresses this with a <b>staged handler pattern</b> that compartmentalises
protocol processing into discrete stages, each with clear goals and decisions:
</p>

<ul>
<li><b>Handler interfaces</b> define callbacks for each protocol stage—the events
your code receives at that point in the conversation</li>
<li><b>State interfaces</b> define the operations available to respond—the valid
transitions from that stage</li>
<li><b>Type safety</b> ensures you can only perform operations valid for the
current protocol state</li>
<li><b>Clear flow</b> makes it obvious what decisions need to be made and what
information is available</li>
</ul>

<p>
For example, an SMTP handler progresses through well-defined stages:
</p>

<pre>
ClientConnected → HelloHandler → MailFromHandler → RecipientHandler → MessageDataHandler
</pre>

<p>
At each stage, the handler receives protocol events (EHLO, MAIL FROM, RCPT TO)
and uses the provided state interface to accept, reject, or make policy
decisions. The protocol handler manages all protocol mechanics &mdash; SASL
authentication challenges, TLS negotiation, command parsing &mdash; leaving
the service to focus on business logic. Services need not be aware of the
underlying transport.
</p>

<h4>Services and Clients</h4>

<p>
The same pattern works for both services (server side) and clients. An SMTP
client handler receives events from the server (greeting, EHLO response,
authentication challenges) and uses state interfaces to drive the conversation
forward. This symmetry simplifies relay implementations where a server
connection drives a client connection.
</p>

<h4>Default Services</h4>

<p>
Each protocol includes default service implementations for common use cases:
</p>

<ul>
<li><b>SMTP</b> &ndash; <code>LocalDeliveryService</code> for mailbox delivery,
<code>SimpleRelayService</code> for MX forwarding</li>
<li><b>IMAP</b> &ndash; <code>DefaultIMAPService</code> accepts all operations
using the configured Realm and MailboxFactory</li>
<li><b>POP3</b> &ndash; <code>DefaultPOP3Service</code> accepts all operations
using the configured Realm and MailboxFactory</li>
</ul>

<p>
These services handle the common case while serving as examples for custom
implementations. In many deployments, the default services with appropriate
configuration are sufficient.
</p>

<h3>Datagram Facilities</h3>

<p>
For UDP-based protocols, <code>UDPEndpoint</code> (via
<code>UDPTransportFactory</code>) provides the same event-driven model. The
<code>ProtocolHandler</code> interface is reused: <code>receive()</code>
delivers individual datagrams and <code>sendTo()</code> addresses responses to
the source.
</p>

<p>
The DNS server demonstrates this abstraction, providing a complete DNS proxy
that can be subclassed for custom name resolution. DTLS (TLS for UDP) is
supported transparently, with per-remote-address session management handled
automatically.
</p>

<h3>Transparent TLS</h3>

<p>
All endpoints support transparent TLS encryption. The framework handles:
</p>

<ul>
<li><b>Implicit TLS</b> - endpoint starts encrypted (HTTPS, IMAPS, POP3S)</li>
<li><b>STARTTLS</b> - upgrade from cleartext to TLS mid-session</li>
<li><b>Client authentication</b> - optional or required client certificates</li>
<li><b>SNI</b> - Server Name Indication for virtual hosting</li>
<li><b>ALPN</b> - Application Layer Protocol Negotiation (HTTP/3, HTTP/2)</li>
<li><b>DTLS</b> - TLS for UDP protocols</li>
<li><b>QUIC</b> - always TLS 1.3 via BoringSSL</li>
</ul>

<p>
To enable TLS, configure the keystore on any listener:
</p>

<pre>
&lt;service class="org.bluezoo.gumdrop.smtp.SMTPService"&gt;
    &lt;listener class="org.bluezoo.gumdrop.smtp.SMTPListener" port="465" secure="true"&gt;
        &lt;property name="keystore-file" path="keystore.p12"/&gt;
        &lt;property name="keystore-pass" value="secret"/&gt;
    &lt;/listener&gt;
&lt;/service&gt;
</pre>

<h4>UNIX Domain Sockets</h4>

<p>
Any TCP-based listener can also bind to a UNIX domain socket by specifying a
<code>path</code> instead of a <code>port</code>. This uses the standard NIO
UNIX domain socket support available since Java 16 (JEP 380). Once accepted,
UNIX domain socket connections behave identically to TCP connections &mdash; the
same <code>SocketChannel</code>, <code>TCPEndpoint</code>, and
<code>ProtocolHandler</code> infrastructure is used unchanged.
</p>

<p>
UNIX domain sockets are useful for local inter-process communication where
network overhead is unnecessary and filesystem permissions provide the security
boundary. A common pattern is to expose a service on both TCP (for remote
clients) and a UNIX socket (for local tools or reverse proxies):
</p>

<pre>
&lt;service class="org.bluezoo.gumdrop.smtp.LocalDeliveryService"&gt;
    &lt;property name="mailbox-factory" ref="#mbox"/&gt;
    &lt;property name="local-domain" value="example.com"/&gt;
    &lt;!-- TCP listener for remote clients --&gt;
    &lt;listener class="org.bluezoo.gumdrop.smtp.SMTPListener"
              name="tcp" port="25"/&gt;
    &lt;!-- UNIX domain socket for local delivery --&gt;
    &lt;listener class="org.bluezoo.gumdrop.smtp.SMTPListener"
              name="unix" path="/var/run/smtp.sock"/&gt;
&lt;/service&gt;
</pre>

<p>
The <code>path</code> and <code>port</code> attributes are mutually exclusive on
a single listener element. Specifying both is a configuration error. Stale
socket files from previous runs are automatically removed on bind, and the
socket file is deleted on shutdown.
</p>

<h4>Endpoint Lifecycle</h4>

<p>
Servers provide configurable endpoint lifecycle management:
</p>

<ul>
<li><b>Idle timeout</b> - close endpoints with no activity (default: 5 minutes)</li>
<li><b>Read timeout</b> - maximum wait for data during active read (default: 30 seconds)</li>
<li><b>Connection timeout</b> - time allowed for initial connection and TLS handshake
(default: 60 seconds)</li>
</ul>

<p>
Timeouts can be configured with time unit suffixes (<code>ms</code>, <code>s</code>,
<code>m</code>, <code>h</code>):
</p>

<pre>
&lt;service class="org.bluezoo.gumdrop.imap.IMAPService"&gt;
    &lt;listener class="org.bluezoo.gumdrop.imap.IMAPListener"&gt;
        &lt;property name="idle-timeout" value="30m"/&gt;
        &lt;property name="read-timeout" value="60s"/&gt;
        &lt;property name="connection-timeout" value="2m"/&gt;
    &lt;/listener&gt;
&lt;/service&gt;
</pre>

<p>
Endpoints track timestamps for creation, last activity, and connection establishment
(after TLS handshake for secure endpoints). These are accessible via
<code>getTimestampCreated()</code>, <code>getTimestampLastActivity()</code>, and
<code>getTimestampConnected()</code>.
</p>

<h3>Configuration</h3>

<p>
Gumdrop uses a lightweight dependency injection framework to wire together its
components from an XML configuration file. See the
<a href="configuration.html">Configuration</a> documentation for full details
on component declarations, property syntax (<code>value</code>,
<code>path</code>, and <code>ref</code> attributes), type conversion,
collections, services and listeners, and example configurations.
</p>

<h3>About the Logo</h3>

<p>
The Gumdrop logo is a gumdrop torus, generated using
<a href="http://www.povray.org/">POV-Ray</a>. A gumdrop torus is a
<a href="http://www.povray.org/documentation/view/3.6.1/448/#s02_07_07_02_i75">mathematical
construct</a>—the logo is such a torus viewed from an angle that makes it
resemble the letter G. All images were created using POV-Ray and/or GIMP and
are copyright 2005 Chris Burdess.
</p>

<h3>Where to go from here</h3>

<p>
Explore the protocol-specific documentation linked above, or examine the
example configurations and test applications. If the speed, simplicity, and
ease of configuration appeals to you, please consider getting involved and
developing a new feature.
</p>

<p>
If you have any questions about Gumdrop, please direct them to
<a href='mailto:dog@gnu.org'>Chris Burdess</a>.
</p>

<p>
Thanks for trying out Gumdrop.
</p>

<p class='server-info'>Gumdrop</p>

</body>
</html>
